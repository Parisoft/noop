/*
 * generated by Xtext 2.11.0
 */
package com.github.parisoft.noop.validation

import com.github.parisoft.noop.nOOP.Expression
import com.github.parisoft.noop.nOOP.NOOPPackage
import com.github.parisoft.noop.nOOP.SJBlock
import com.github.parisoft.noop.nOOP.SJClass
import com.github.parisoft.noop.nOOP.SJField
import com.github.parisoft.noop.nOOP.SJMemberSelection
import com.github.parisoft.noop.nOOP.SJMethod
import com.github.parisoft.noop.nOOP.SJNamedElement
import com.github.parisoft.noop.nOOP.SJProgram
import com.github.parisoft.noop.nOOP.SJReturn
import com.github.parisoft.noop.nOOP.SJSuper
import com.github.parisoft.noop.nOOP.SJVariableDeclaration
import com.github.parisoft.noop.scoping.NOOPIndex
import com.github.parisoft.noop.typing.NOOPTypeComputer
import com.github.parisoft.noop.typing.NOOPTypeConformance
import com.github.parisoft.noop.util.NOOPUtils
import com.google.common.collect.HashMultimap
import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType

import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class NOOPValidator extends AbstractNOOPValidator {
	
protected static val ISSUE_CODE_PREFIX = "org.example.smalljava."
	public static val HIERARCHY_CYCLE = ISSUE_CODE_PREFIX + "HierarchyCycle"
	public static val FIELD_SELECTION_ON_METHOD = ISSUE_CODE_PREFIX + "FieldSelectionOnMethod"
	public static val METHOD_INVOCATION_ON_FIELD = ISSUE_CODE_PREFIX + "MethodInvocationOnField"
	public static val UNREACHABLE_CODE = ISSUE_CODE_PREFIX + "UnreachableCode"
	public static val MISSING_FINAL_RETURN = ISSUE_CODE_PREFIX + "MissingFinalReturn"
	public static val DUPLICATE_ELEMENT = ISSUE_CODE_PREFIX + "DuplicateElement"
	public static val INCOMPATIBLE_TYPES = ISSUE_CODE_PREFIX + "IncompatibleTypes"
	public static val INVALID_ARGS = ISSUE_CODE_PREFIX + "InvalidArgs"
	public static val WRONG_METHOD_OVERRIDE = ISSUE_CODE_PREFIX + "WrongMethodOverride"
	public static val MEMBER_NOT_ACCESSIBLE = ISSUE_CODE_PREFIX + "MemberNotAccessible"
	public static val DUPLICATE_CLASS = ISSUE_CODE_PREFIX + "DuplicateClass"
	public static val WRONG_SUPER_USAGE = ISSUE_CODE_PREFIX + "WrongSuperUsage"
	public static val REDUCED_ACCESSIBILITY = ISSUE_CODE_PREFIX + "ReducedAccessibility"

	@Inject extension NOOPUtils
	@Inject extension NOOPTypeComputer
	@Inject extension NOOPTypeConformance
//	@Inject extension NOOPAccessibility
	@Inject extension NOOPIndex
	@Inject extension IQualifiedNameProvider

	@Check
	def checkClassHierarchy(SJClass c) {
		if (c.classHierarchy.contains(c)) {
			error("cycle in hierarchy of class '" + c.name + "'", NOOPPackage.eINSTANCE.SJClass_Superclass,
				HIERARCHY_CYCLE, c.superclass.name)
		}
	}

	@Check
	def void checkMemberSelection(SJMemberSelection sel) {
		val member = sel.member

		if (member instanceof SJField && sel.methodInvocation)
			error(
				'''Method invocation on a field''', NOOPPackage.eINSTANCE.SJMemberSelection_MethodInvocation,
				METHOD_INVOCATION_ON_FIELD)
		else if (member instanceof SJMethod && !sel.methodInvocation)
			error(
				'''Field selection on a method''',
				NOOPPackage.eINSTANCE.SJMemberSelection_Member,
				FIELD_SELECTION_ON_METHOD
			)
	}

	@Check
	def void checkUnreachableCode(SJBlock block) {
		val statements = block.statements
		for (var i = 0; i < statements.length - 1; i++) {
			if (statements.get(i) instanceof SJReturn) {
				// put the error on the statement after the return
				error("Unreachable code", statements.get(i + 1), null, // EStructuralFeature
				UNREACHABLE_CODE)
				return // no need to report further errors
			}
		}
	}

	@Check
	def void checkMethodEndsWithReturn(SJMethod method) {
		if (method.returnStatement === null) {
			error(
				"Method must end with a return statement",
				NOOPPackage.eINSTANCE.SJMethod_Body,
				MISSING_FINAL_RETURN
			)
		}
	}

	@Check def void checkNoDuplicateClasses(SJProgram p) {
		checkNoDuplicateElements(p.classes, "class")
	}

	@Check def void checkNoDuplicateMembers(SJClass c) {
		checkNoDuplicateElements(c.fields, "field")
		checkNoDuplicateElements(c.methods, "method")
	}

	@Check def void checkNoDuplicateSymbols(SJMethod m) {
		checkNoDuplicateElements(m.params, "parameter")
//		checkNoDuplicateElements(m.body.getAllContentsOfType(SJVariableDeclaration), "variable")
		checkNoDuplicateVariables(m.body.getAllContentsOfType(SJVariableDeclaration))
	}

	def private checkNoDuplicateVariables(List<? extends SJNamedElement> variables) {
		var offset = 1;

		for (variable : variables) {
			val others = variables.drop(offset++)

			for (other : others) {
				if (variable.name.equals(other.name) && variable.containerBlock.isAncestor(other.containerBlock)) {
					error('''Duplicated variable '«variable.name»' ''', other,
						NOOPPackage.eINSTANCE.SJNamedElement_Name, DUPLICATE_ELEMENT)
				}
			}
		}
	}

	def containerBlock(EObject object) {
		var parent = object.eContainer

		while (parent !== null) {
			if (parent instanceof SJBlock) {
				return parent
			}

			parent = parent.eContainer
		}

		return null
	}

	@Check def void checkConformance(Expression exp) {
		val actualType = exp.typeFor
		val expectedType = exp.expectedType
		if (expectedType === null || actualType === null)
			return; // nothing to check
		if (!actualType.isConformant(expectedType)) {
			error("Incompatible types. Expected '" + expectedType.name + "' but was '" + actualType.name + "'", null,
				INCOMPATIBLE_TYPES);
		}
	}

	@Check def void checkMethodInvocationArguments(SJMemberSelection sel) {
		val method = sel.member
		if (method instanceof SJMethod) {
			if (method.params.size != sel.args.size) {
				error("Invalid number of arguments: expected " + method.params.size + " but was " + sel.args.size,
					NOOPPackage.eINSTANCE.SJMemberSelection_Member, INVALID_ARGS)
			}
		}
	}

	@Check def void checkMethodOverride(SJClass c) {
		val hierarchyMethods = c.classHierarchyMethods

		for (m : c.methods) {
			val overridden = hierarchyMethods.get(m.name)
			if (overridden !== null && (!m.type.isConformant(overridden.type) ||
				!m.params.map[type].elementsEqual(overridden.params.map[type]))) {
				error("The method '" + m.name + "' must override a superclass method", m,
					NOOPPackage.eINSTANCE.SJNamedElement_Name, WRONG_METHOD_OVERRIDE)
			} else if (m.access < overridden.access) {
				error("Cannot reduce access from " + overridden.access + " to " + m.access, m,
					NOOPPackage.eINSTANCE.SJMember_Access, REDUCED_ACCESSIBILITY)
			}
		}
	}

//	@Check def void checkAccessibility(SJMemberSelection sel) {
//		val member = sel.member
//		if (member.name !== null && !member.isAccessibleFrom(sel))
//			error(
//				'''The «member.access» member «member.name» is not accessible here''',
//				NOOPPackage.eINSTANCE.SJMemberSelection_Member,
//				MEMBER_NOT_ACCESSIBLE
//			)
//	}

	// perform this check only on file save
	@Check(CheckType.NORMAL)
	def checkDuplicateClassesInFiles(SJProgram p) {
		val externalClasses = p.getVisibleExternalClassesDescriptions
		for (c : p.classes) {
			val className = c.fullyQualifiedName
			if (externalClasses.containsKey(className)) {
				error("The type " + c.name + " is already defined", c, NOOPPackage.eINSTANCE.SJNamedElement_Name,
					DUPLICATE_CLASS)
			}
		}
	}

	@Check
	def void checkSuper(SJSuper s) {
		if (s.eContainingFeature != NOOPPackage.eINSTANCE.SJMemberSelection_Receiver)
			error("'super' can be used only as member selection receiver", null, WRONG_SUPER_USAGE)
	}

	def private void checkNoDuplicateElements(Iterable<? extends SJNamedElement> elements, String desc) {
		val multiMap = HashMultimap.create()

		for (e : elements)
			multiMap.put(e.name, e)

		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					error("Duplicate " + desc + " '" + d.name + "'", d, NOOPPackage.eINSTANCE.SJNamedElement_Name,
						DUPLICATE_ELEMENT)
			}
		}
	}
	
}
