Field structure
---------------
1. Object fields are not pointers, the bytes are stored at sequencial orther as declared:
	Ex.:

	Noop:
	Ball {
		x : 0
		y : 0
	}

	Paddle {
		y: 0
		ball : new Ball
	}

	Pong extends Game {
		ball : new Ball
		paddle1 : new Paddle
		paddle2 : new Paddle
	}

	ASM:
	enum:
	pong .bsb 2+3+3 ; 2 for ball plus 3 for each paddle
	ende:

2. Each class field will be labeled with the offset for indirect access
	Ex.:

	Noop:
	Ball {
		x : 0
		y : 0
	}

	ASM:
	Ball.x = 1
	Ball.y = Ball.x + 1

3. The size of a class is stored into a label (for equals usage):
	Ex.:

	Noop:
	Ball {
		x : 0
		y : 0
	}

	ASM:
	Ball.sizeOf = $0003 ; 1 for x + 1 for y + 1 for class = 3 bytes

4. A field type cannot be the owner type or any inherited type of the owner
	Ex.:
	Ball {
		other : new Ball //invalid, cannot be the same type
		sqr : new SquareBall //invalid, cannot be an inherited type
	}

	SquareBall extends Ball {
		other : new Ball //valid, Ball is not inherited by SquareBall
		some : new SquareBall // invalid, cannot be the same type
	}

5. Deprecated! A field value can have the value overriden, but with the same type, dimension and length
	Ex.:

	Noop:
	Players {
		qty : 3
		list : Player[3]
	}

	OtherPlayers extends Players {
		qty : false //invalid: super.qty is of type UByte not Bool
		list : Player[5][3] // invalid: super.list length is 3 not 5, also super.list dimension is 1 not 2
	}
5. A field cannot have this value overriden

Field assignment
----------------
1. When a value is assigned to a field, the field bytes is overiten to the new value
2. Since fields are not pointers, an assignment to an object or array is the same as coping the value
	Ex.:

	Noop:
	Player {
		score : 0
	}
	Paddle {
		owner : new Player
	}
	...
	p1 : new Paddle
	p2 : new Paddle { owner : new Player { score : 10 } }
	p1.owner := p2.owner //copy all values from one owner to another; both have score 10 now
	p1.owner.equals(p2.owner) //evaluates to true
	p2.owner.score := 16 //since owner is not a pointer, only the p2 owner is changed
	p1.owner.equals(p2.owner) //evaluates to false

Field reference
---------------
1. To read a field, the access is made indirectly usind the fields offset label:
	Ex.:

	Noop:
	Ball {
		x : 0
		y : 0
	}
	...
	ball.y

	ASM:
	Ball.x = 1 ; the 1st byte is the class ID, 2nd is x is this case
	Ball.y = Ball.x + 1; 3rd byte is y
	...
	LDY #Ball.y ; read the offset, whose is 2 in this case
	LDA (ballPtr), Y ; read the value pointed by ballPtr at index Y
	LDA ball, Y ; read the value of ball at index Y

Field injection
---------------
1. An injected field is a reference to a singleton object
2. An injected field acts as a static field (a field from the class, not the instance)
3. The singleton instance is determined by its type
4. A singleton instance cannot be an array
5. At compile time, when a injection appears, if the singleton instance don't exists its is created
6. The reference is a label to the singleton instance:
	Ex.:

	Noop:
	Paddle {
		ball : inject Ball
	}

	ASM:
	enum:
	singletonBall .bsb Ball.sizeOf
	nume
	...
	Paddle.ball = singletonBall

7. Varibles can be injected too:
	Ex.:

	Noop:
	Paddle {
		isColliding() {
			ball : inject Ball
			...
		}
	}

	ASM:
	enum:
	singletonBall .bsb Ball.sizeOf
	nume
	...
	Paddle.isColliding.ball = singletonBall

8. Injections can be used only on declarations, not on assignments:
	Ex.:

	Noop:
	ball1 : inject Ball //valid, cause its a declaration
	ball2 : new Ball
	ball2 := inject Ball //invalid, cause its an assignment
	ball2 := ball1 //valid, the values of the singleton instance is copied to the variable
	ball1 := new Ball //valid, the values of new instance is copied to the singleton instance
	ball3 := inject Ball
	ball1 = ball3 //evaluates to true, since both ball1 and ball3 points to the same instance 


Field inclusions
----------------
1. An included field is the bytes from an external file
2. Included fields cannot be overriden (just like any field)
3. An included field acts as a static field (a field from the class, not the instance)
4. An included field cannt be reassigned
5. Inclusions cannot be used on variables, only fields
6. The type of a included field is Byte[] with length same as file size
Ex.:

Pong extends Game {
	
	sprites : include "pong.chr" // assuming pong.chr size is 8Kb, sprites type is Byte[8192]
}

Location annotation
-------------------
1. A field or method can be annotaded with a location to determine where it will be stored
2. Field annotations: @PrgROM(bank:?), @ChrROM(bank:?), @VRAM, @SRAM
3. Method annotations: @PrgROM(bank:?)
4. Whenever a filed or method is accessed, an automatic bankswitch is performed. Its is acquired by a code writen at compile time according to the configured mapper
5. Annotated methods can be overriden (the bankswitch is writen on the super method, where the redirection occurs; see Method Override (3))

Ex.:

Pong extends Game {
	
	@ChrROM
	sprites : include "pong.chr"
}

Method Override
---------------
1. Label each class as an ID in ZP (max of 256)
	Ex.:
	
	Noop:
	Ball {
		...
	}
	Paddle {
		...
	}
	
	ASM:
	Object.class = $0000
	Ball.class = $0001
	Paddle.class = $0002

2. Reserve 1 byte for object's class
	Ex.:
	
	Noop:
	Ball {
		x : 222
	}
	...
	ball : new Ball
	...
	
	ASM:
	ball .bsb 2 // 1 for class plus 1 for x
	...
	LDA #<Ball.class
	STA ball ; initialize the class id into instance
	LDA #222 ; initialize other fields of instance
	STA ball+1 // or STA a+Ball.x , where Ball.x is a label for field x offset is class Ball

3. All overriden methods redirect the invocation to the right implementations unless the flag 'supercall' is set to true
	Ex.:
	
	Noop:
	Ball {
		move(){
			...
		}
	}
	SquareBall {
		move(){
			...
		}
	}
	
	ASM:
	Ball.move:
		LDA supercall
		CMP #$01
		BEQ Ball.move.continue ; if is a super.move(), continue into this method 
		LDA receiver ; receiver is the 1st arg of any Method and the 1st byte contains the class ID
		CMP #Ball.class
		BEQ Ball.move.continue ; if the receiver is a instance of this class, continue
		JMP receiver.move ; else, redirect to the right implementation (how to do this, a switch-case?)
	Ball.move.continue:
		...
		RTS
	SquareBall.move:
		...
		RTS

Cast
----
1. Only at compile level
2. At validations level:
	2.1 Pass when both classes are Numbers
		Ex.: aByte.as(Int)
	2.2 Warn when the receiver class inherits or is the same as the cast class (useless cast) 
		EX.: A<-B<-C and b.as(A) or b.as(B)
	2.2 Warn when the receiver class is inherited by the cast class and the cast is not inside a if(instanceOf) instatement (unchecked cast)
		Ex.: A<-B<-C and b.as(C)
	2.1 Error when the receiver class do not inherit nor is inherited by the cast class
		Ex.: A<-B<-C and b.as(D)

Super call
----------
1. The method is redirected to the super method with the flag 'supercall' sets to true (see 'Method Override')
2. At compile level, the ASM is writen as:
	Pseudo:
	AClass extends Other {
		aMethod() {
		   super.aMethod()
		}
	}
	
	ASM:
	AClass.aMethod:
		LDA #01
		STA supercall
		JMP Other.aMethod


Type check
----------------
1. Writen at compile level
2. Each class will have an implementation:
	instanceOf(Class) {
		return this.class == Class || super.instanceOf(Class)
	}
	
	Ex.:
	
	Noop:
	Ball {

	}
	SquareBall {

	}
	
	ASM:
	SquareBall.instanceOf:
		LDA receiver ; 1st byte of receiver is a class ID
		CMP #SquareBall.class ; compare the receiver class ID with this class ID
		BEQ SquareBall.instanceOf.return ; return true if equals
		JMP Ball.instanceOf ; redirect to super otherwise
	SquareBall.instanceOf.return:
		LDA #01
		STA ret
		RTS

	Ball.instanceOf:
		LDA receiver ; 1st byte of receiver is a class ID
		CMP #Ball.class ; compare the receiver class ID with this class ID
		BEQ Ball.instanceOf.return ; return true if equals
		JMP Object.instanceOf ; redirect to super otherwise
	Ball.instanceOf.return:
		LDA #01
		STA ret
		RTS

	Object.instanceOf:
		LDA #Object.class ; Object.class is always the 1st ID with value 0
		CMP receiver ; compare the receiver class ID with this class ID
		BNE Object.instanceOf.return ; returns false if not equals
	Object.instanceOf.ok
		INC ; set the return value to true
	Object.instanceOf.return
		STA ret
		RTS

3. Primitives are resolved at compile level:
	Ex.:

	Noop:
	b : 318
	b.instanceOf(UByte) // the expression will be resolved to true (01) at compile time
	c : b.as(Int) // c will have the b's value but typed as Int, at compile time

Comparison
----------
1. Comparison is made by method Object.equals()
2. Comparing a = b is same as a.equals(b)
3. Comparing a # b is same as 'not a.equals(b)'
4. The equals method algorithm is as folows:
	4.1 First, it redirects to the right implementation (see 'Method Override')
	4.2 Each byte is compared, returning false on first difference, or true if none differ 
4. The equals method is writen for each class in compile time, unless it's overriden:
	Ex.:

	Noop:
	Ball {
	...	
	}

	ASM:
	Ball.equals:
		... ; redirect if needed (see 'Method Override')
		LDA #00 ; assume not equals
		LDY #00 ; points Y to the 1st byte (class type) 
	Ball.equals.loop:
		LDA (receiver), Y
		CMP (other), Y
		BNE Ball.equals.return ; if types differs, return false
		INY
		CPY #Ball.sizeOf
		BNE Ball.equals.loop:
		INC ; loop finish, all bytes match so return true
	Ball.equals.return:
		STA ret
		RTS

Color names
-----------
x1 - azure
x2 - blue
x3 - purple
x4 - magenta
x5 - pink
x6 - red
x7 - orange
x8 - yellow
x9 - lime
xA - green
xB - mint
xC - cyan

Mem Stack
---------

Pages
	$0000-$00FD pointers
	$00FG-$00FF	return pointer
	$0400-$077B	local values
	$077C-$0780 return values
	$0781-$07FF args values

1. $0000-$00FD pointers
	ZP dedicated for all kind of pointers (global, local and args references)
2. $00FG-$00FF	return pointer
	2 bytes (1 pointer) dedicated for methods that return objects and arrays
3. $0400-$077B	local values
	3.1. 3 1/2~ pages for data
	3.2. global data comes first on $0400
	3.3. local data begins after last byte of global data
	3.4. at compile time, when a method is invoked, the space for local vars is allocated as follows:
	3.4.1 the method's size (size of all local variable, excluding constants) is calculated*
	3.4.2 the size is compared with current page, if greather the page is shifted
4. $077C-$0780 return values
	4.1 5 bytes for returned primitives or array metadata
	4.2 when returning an array:
	4.2.1 the return pointer points to the head of array
	4.2.2 the byte at $077C contains the array's element size
	4.2.3 the byte at $077D contains the array's dimension
	4.2.4 the bytes at $077E, $077F, $0780 contains the array's dimension length (max 3)
5. $0781-$07FF args values
	Half page dedicated for methods arguments, including arrays metadata

* a look-ahead is performed when referencing an object or array returned from a method call; if the returned object or array was instancied locally on callee method, the object's bytes must be moved to the caller and the pointer updated after callee returns; these bytes must be considerated on the method's size calculation

TODO:
	method
		recursion check in compile
		polymorphic non static invocation check