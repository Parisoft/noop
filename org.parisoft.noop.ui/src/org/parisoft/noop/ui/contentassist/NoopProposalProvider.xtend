/*
 * generated by Xtext 2.10.0
 */
package org.parisoft.noop.ui.contentassist

import com.google.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.jface.viewers.StyledString
import org.eclipse.swt.graphics.Image
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.ui.editor.hover.IEObjectHover
import org.parisoft.noop.^extension.Classes
import org.parisoft.noop.^extension.Expressions
import org.parisoft.noop.^extension.Members
import org.parisoft.noop.noop.Block
import org.parisoft.noop.noop.ForStatement
import org.parisoft.noop.noop.Member
import org.parisoft.noop.noop.MemberSelect
import org.parisoft.noop.noop.Method
import org.parisoft.noop.noop.NewInstance
import org.parisoft.noop.noop.NoopClass
import org.parisoft.noop.noop.Variable
import org.parisoft.noop.ui.labeling.NoopLabelProvider

import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension org.eclipse.xtext.nodemodel.util.NodeModelUtils.*

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class NoopProposalProvider extends AbstractNoopProposalProvider {

	@Inject extension Members
	@Inject extension Classes
	@Inject extension Expressions

	@Inject NoopLabelProvider labelProvider
	@Inject IEObjectHover hover

	override completeSelectionExpression_Member(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if (model instanceof MemberSelect) {
			val receiver = model.receiver
			val variables = receiver.typeOf.allFieldsTopDown.filter[isAccessibleFrom(model)].suppressHeaders
			val methods = receiver.typeOf.allMethodsTopDown.filter[isAccessibleFrom(model)]

			if (receiver.dimensionOf.size > 0) {
				methods.filter[nonStatic].filter[nativeArray].suppressOverriden.forEach [ method |
					acceptor.accept(method.createCompletionProposal(context))
				]
			} else if (receiver instanceof NewInstance) {
				if (receiver.constructor === null) {
					variables.filter[static].suppressOverriden.forEach [ variable |
						acceptor.accept(variable.createCompletionProposal(context))
					]
					methods.filter[static].suppressOverriden.forEach [ method |
						acceptor.accept(method.createCompletionProposal(context))
					]
				} else {
					variables.filter[nonStatic].suppressOverriden.forEach [ variable |
						acceptor.accept(variable.createCompletionProposal(context))
					]
					methods.filter[nonStatic].filter[nonNativeArray].suppressOverriden.forEach [ method |
						acceptor.accept(method.createCompletionProposal(context))
					]
				}
			} else {
				variables.filter[nonStatic].suppressOverriden.forEach [ variable |
					acceptor.accept(variable.createCompletionProposal(context))
				]
				methods.filter[nonStatic].filter[nonNativeArray].suppressOverriden.forEach [ method |
					acceptor.accept(method.createCompletionProposal(context))
				]
			}
		} else {
			super.completeSelectionExpression_Member(model, assignment, context, acceptor)
		}
	}

	override completeTerminalExpression_Member(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val nonStatic = model.getContainerOfType(Method)?.isNonStatic

		if (nonStatic) {
			model.completeMemberRef(context).forEach [ variable |
				acceptor.accept(variable.createCompletionProposal(context))
			]
			model.containerClass.allMethodsTopDown.filter[nonNativeArray].suppressOverriden.forEach [ method |
				acceptor.accept(method.createCompletionProposal(context))
			]
		} else {
			model.completeMemberRef(context).filter[static].forEach [ variable |
				acceptor.accept(variable.createCompletionProposal(context))
			]
			model.containerClass.allMethodsTopDown.filter[static].filter[nonNativeArray].suppressOverriden.forEach [ method |
				acceptor.accept(method.createCompletionProposal(context))
			]
		}

	}

	private def Iterable<Variable> completeMemberRef(EObject model, ContentAssistContext context) {
		if (model === null) {
			return newArrayList
		}

		return switch (model) {
			Block:
				model.statements.takeWhile[node.startLine < context.currentNode.startLine].filter(Variable)
			ForStatement:
				model.variables.takeWhile[node.offset < context.currentNode.offset].filter[value !== null]
			Method:
				model.params
			NoopClass:
				model.allFieldsTopDown.takeWhile [
					node.startLine < context.currentNode.startLine
				].suppressOverriden.suppressHeaders
			default:
				newArrayList
		} + model.eContainer.completeMemberRef(context)
	}

	override completeKeyword(Keyword keyword, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		return
	}

	override protected doCreateProposal(String proposal, StyledString displayString, Image image, int replacementOffset,
		int replacementLength) {
		new NoopMethodCompletionProposal(proposal, replacementOffset, replacementLength, proposal.length(), image,
			displayString, null, null)
	}

	private def createCompletionProposal(Member member, ContentAssistContext context) {
		val priority = if (member instanceof Variable) {
				if (member.isStatic) {
					4000
				} else if (member.isField) {
					5000
				} else {
					6000
				}
			} else if (member.isStatic) {
				2000
			} else {
				3000
			}

		val prefix = context.prefix
		val proposal = createCompletionProposal(member.name, member.text, member.image, priority, prefix, context)

		if (proposal instanceof NoopMethodCompletionProposal) {
			proposal => [
				it.hover = hover
				it.additionalProposalInfo = member

				if (member instanceof Method) {
					it.setLinkedMode(context.viewer, member)
				}
			]
		}
	}

	private def suppressHeaders(Iterable<Variable> variables) {
		variables.filter[typeOf.nonINESHeader]
	}

	private def <M extends Member> suppressOverriden(Iterable<M> members) {
		val suppressed = newHashSet

		members.forEach [ member, i |
			suppressed += members.drop(i + 1).findFirst[member.isOverrideOf(it)]
			suppressed += if (members.drop(i + 1).exists[isOverrideOf(member)]) {
				member
			}
		]

		members.filter[!suppressed.contains(it)]
	}

	private dispatch def text(NoopClass c) {
		labelProvider.text(c)
	}

	private dispatch def text(Method m) {
		labelProvider.text(m)
	}

	private dispatch def text(Variable v) {
		labelProvider.text(v)
	}

}
