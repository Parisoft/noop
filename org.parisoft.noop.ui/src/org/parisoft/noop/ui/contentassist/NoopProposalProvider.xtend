/*
 * generated by Xtext 2.10.0
 */
package org.parisoft.noop.ui.contentassist

import com.google.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.jface.viewers.StyledString
import org.eclipse.swt.graphics.Image
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.ui.editor.hover.IEObjectHover
import org.parisoft.noop.^extension.Classes
import org.parisoft.noop.^extension.Expressions
import org.parisoft.noop.^extension.Members
import org.parisoft.noop.noop.Member
import org.parisoft.noop.noop.MemberSelect
import org.parisoft.noop.noop.Method
import org.parisoft.noop.noop.NewInstance
import org.parisoft.noop.noop.Variable
import org.parisoft.noop.ui.labeling.NoopLabelProvider

import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class NoopProposalProvider extends AbstractNoopProposalProvider {

	@Inject extension Members
	@Inject extension Classes
	@Inject extension Expressions

	@Inject NoopLabelProvider labelProvider
	@Inject IEObjectHover hover

//	val keywordsToIgnore = newArrayList('.', 'if', 'else', 'for', 'forever')

	override completeSelectionExpression_Member(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if (model instanceof MemberSelect) {
			val receiver = model.receiver
			val variables = receiver.typeOf.allFieldsTopDown.filter[isAccessibleFrom(model)].sortBy[name]
			val methods = receiver.typeOf.allMethodsTopDown.filter[isAccessibleFrom(model)].sortBy[name]

			if (receiver.dimensionOf.size > 0) {
				methods.filter[nonStatic].filter[nativeArray].suppressOverriden.forEach [ method |
					acceptor.accept(method.createCompletionProposal(context))
				]
			} else if (receiver instanceof NewInstance) {
				if (receiver.constructor === null) {
					variables.filter[static].suppressOverriden.forEach [ variable |
						acceptor.accept(variable.createCompletionProposal(context))
					]
					methods.filter[static].suppressOverriden.forEach [ method |
						acceptor.accept(method.createCompletionProposal(context))
					]
				} else {
					variables.filter[nonStatic].suppressOverriden.forEach [ variable |
						acceptor.accept(variable.createCompletionProposal(context))
					]
					methods.filter[nonStatic].filter[nonNativeArray].suppressOverriden.forEach [ method |
						acceptor.accept(method.createCompletionProposal(context))
					]
				}
			} else {
				variables.filter[nonStatic].suppressOverriden.forEach [ variable |
					acceptor.accept(variable.createCompletionProposal(context))
				]
				methods.filter[nonStatic].filter[nonNativeArray].suppressOverriden.forEach [ method |
					acceptor.accept(method.createCompletionProposal(context))
				]
			}
		} else {
			super.completeSelectionExpression_Member(model, assignment, context, acceptor)
		}
	}

	override completeTerminalExpression_Member(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val nonStatic = model.getContainerOfType(Method)?.isNonStatic

		if (nonStatic) {
			model.containerClass.allMethodsTopDown.filter[nonNativeArray].suppressOverriden.sortBy[name].forEach [ method |
				acceptor.accept(method.createCompletionProposal(context))
			]
		} else {
			model.containerClass.allMethodsTopDown.filter[static].filter[nonNativeArray].suppressOverriden.sortBy[name].
				forEach [ method |
					acceptor.accept(method.createCompletionProposal(context))
				]
		}
	}

	override completeSelectionExpression_Args(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		super.completeSelectionExpression_Args(model, assignment, context, acceptor)
	}

	override completeKeyword(Keyword keyword, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		return
	}

	override protected doCreateProposal(String proposal, StyledString displayString, Image image, int replacementOffset,
		int replacementLength) {
		new NoopMethodCompletionProposal(proposal, replacementOffset, replacementLength, proposal.length(), image,
			displayString, null, null)
	}

	private def createCompletionProposal(Variable variable, ContentAssistContext context) {
		createCompletionProposal(variable.name, variable.text, variable.image, context)
	}

	private def createCompletionProposal(Method method, ContentAssistContext context) {
		val proposal = createCompletionProposal(method.name, method.text, method.image, context)

		if (proposal instanceof NoopMethodCompletionProposal) {
			proposal => [
				it.hover = hover
				it.setLinkedMode(context.viewer, method)
			]
		}
	}

	private def <M extends Member> suppressOverriden(Iterable<M> members) {
		val suppressed = newHashSet

		members.forEach [ member, i |
			suppressed += members.drop(i + 1).findFirst[member.isOverrideOf(it)]
			suppressed += if (members.drop(i + 1).exists[isOverrideOf(member)]) {
				member
			}
		]

		members.filter[!suppressed.contains(it)]
	}
	
	private def text(Method m) {
		labelProvider.text(m)
	}
	
	private def text(Variable v) {
		labelProvider.text(v)
	}

}
