/*
 * generated by Xtext 2.10.0
 */
package org.parisoft.noop.validation

import com.google.inject.Inject
import java.io.File
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import org.parisoft.noop.exception.NonConstantExpressionException
import org.parisoft.noop.^extension.Classes
import org.parisoft.noop.^extension.Collections
import org.parisoft.noop.^extension.Expressions
import org.parisoft.noop.^extension.Files
import org.parisoft.noop.^extension.Members
import org.parisoft.noop.^extension.TypeSystem
import org.parisoft.noop.noop.AddExpression
import org.parisoft.noop.noop.AndExpression
import org.parisoft.noop.noop.ArrayLiteral
import org.parisoft.noop.noop.AsmStatement
import org.parisoft.noop.noop.AssignmentExpression
import org.parisoft.noop.noop.BAndExpression
import org.parisoft.noop.noop.BOrExpression
import org.parisoft.noop.noop.Block
import org.parisoft.noop.noop.BreakStatement
import org.parisoft.noop.noop.ByteLiteral
import org.parisoft.noop.noop.CastExpression
import org.parisoft.noop.noop.ComplementExpression
import org.parisoft.noop.noop.ConstructorField
import org.parisoft.noop.noop.ContinueStatement
import org.parisoft.noop.noop.DecExpression
import org.parisoft.noop.noop.DifferExpression
import org.parisoft.noop.noop.DivExpression
import org.parisoft.noop.noop.ElseStatement
import org.parisoft.noop.noop.EqualsExpression
import org.parisoft.noop.noop.Expression
import org.parisoft.noop.noop.ForStatement
import org.parisoft.noop.noop.ForeverStatement
import org.parisoft.noop.noop.GeExpression
import org.parisoft.noop.noop.GtExpression
import org.parisoft.noop.noop.IfStatement
import org.parisoft.noop.noop.IncExpression
import org.parisoft.noop.noop.InstanceOfExpression
import org.parisoft.noop.noop.LShiftExpression
import org.parisoft.noop.noop.LeExpression
import org.parisoft.noop.noop.LtExpression
import org.parisoft.noop.noop.MemberRef
import org.parisoft.noop.noop.MemberSelect
import org.parisoft.noop.noop.Method
import org.parisoft.noop.noop.ModExpression
import org.parisoft.noop.noop.MulExpression
import org.parisoft.noop.noop.NewInstance
import org.parisoft.noop.noop.NoopClass
import org.parisoft.noop.noop.NotExpression
import org.parisoft.noop.noop.OrExpression
import org.parisoft.noop.noop.RShiftExpression
import org.parisoft.noop.noop.ReturnStatement
import org.parisoft.noop.noop.SigNegExpression
import org.parisoft.noop.noop.SigPosExpression
import org.parisoft.noop.noop.Statement
import org.parisoft.noop.noop.Storage
import org.parisoft.noop.noop.StorageType
import org.parisoft.noop.noop.StringLiteral
import org.parisoft.noop.noop.SubExpression
import org.parisoft.noop.noop.Super
import org.parisoft.noop.noop.This
import org.parisoft.noop.noop.Variable

import static org.parisoft.noop.noop.AssignmentType.*
import static org.parisoft.noop.noop.NoopPackage.Literals.*

import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class NoopValidator extends AbstractNoopValidator {

	@Inject extension Files
	@Inject extension Classes
	@Inject extension Members
	@Inject extension Expressions
	@Inject extension Collections

	public static val ISSUE_PREFIX = 'org.parisoft.noop'
	public static val CLASS_RECURSIVE_HIERARCHY = 'org.parisoft.noop.CLASS_RECURSIVE_HIERARCHY'
	public static val CLASS_SUPERCLASS_TYPE = 'org.parisoft.noop.CLASS_SUPERCLASS_TYPE'
	public static val CLASS_SIZE_OVERFLOW = 'org.parisoft.noop.CLASS_SIZE_OVERFLOW'
	public static val CLASS_FILE_NAME = 'org.parisoft.noop.CLASS_FILE_NAME'
	public static val FIELD_TYPE_SAME_HIERARCHY = 'org.parisoft.noop.FIELD_TYPE_SAME_HIERARCHY'
	public static val FIELD_CROSS_REFERENCE = 'org.parisoft.noop.FIELD_CROSS_REFERENCE'
	public static val FIELD_STORAGE = 'org.parisoft.noop.FIELD_STORAGE'
	public static val FIELD_DUPLICITY = 'org.parisoft.noop.FIELD_DUPLICITY'
	public static val FIELD_OVERRIDDEN_TYPE = 'org.parisoft.noop.FIELD_OVERRIDDEN_TYPE'
	public static val FIELD_OVERRIDDEN_DIMENSION = 'org.parisoft.noop.FIELD_OVERRIDDEN_DIMENSION'
	public static val STATIC_FIELD_CONTAINER = 'org.parisoft.noop.STATIC_FIELD_CONTAINER'
	public static val STATIC_FIELD_STORAGE_TYPE = 'org.parisoft.noop.STATIC_FIELD_STORAGE_TYPE'
	public static val STATIC_FIELD_UNDECLARED_VALUE = 'org.parisoft.noop.STATIC_FIELD_UNDECLARED_VALUE'
	public static val ROM_FIELD_NON_CONSTANT = 'org.parisoft.noop.ROM_FIELD_NON_CONSTANT'
	public static val INES_FIELD_NON_CONSTANT = 'org.parisoft.noop.INES_FIELD_NON_CONSTANT'
	public static val INES_FIELD_DIMENSION = 'org.parisoft.noop.INES_FIELD_DIMENSION'
	public static val CONSTANT_FIELD_TYPE = 'org.parisoft.noop.CONSTANT_FIELD_TYPE'
	public static val CONSTANT_FIELD_DIMENSION = 'org.parisoft.noop.CONSTANT_FIELD_DIMENSION'
	public static val CONSTANT_FIELD_STORAGE = 'org.parisoft.noop.CONSTANT_FIELD_STORAGE'
	public static val CONSTANT_FIELD_VALUE = 'org.parisoft.noop.CONSTANT_FIELD_VALUE'
	public static val VARIABLE_VOID_TYPE = 'org.parisoft.noop.VARIABLE_VOID_TYPE'
	public static val VARIABLE_DUPLICITY = 'org.parisoft.noop.VARIABLE_DUPLICITY'
	public static val VARIABLE_NEVER_USED = 'org.parisoft.noop.VARIABLE_NEVER_USED'
	public static val VARIABLE_DIMENSION = 'org.parisoft.noop.VARIABLE_DIMENSION'
	public static val PARAMETER_VOID_TYPE = 'org.parisoft.noop.PARAMETER VOID_TYPE'
	public static val PARAMETER_STORAGE_TYPE = 'org.parisoft.noop.PARAMETER_STORAGE_TYPE'
	public static val PARAMETER_DUPLICITY = 'org.parisoft.noop.PARAMETER_DUPLICITY'
	public static val PARAMETER_DIMENSION_VALUE = 'org.parisoft.noop.PARAMETER_DIMENSION_VALUE'
	public static val PARAMETER_DIMENSION_CONSISTENCE = 'org.parisoft.noop.PARAMETER_DIMENSION_CONSISTENCE'
	public static val PARAMETER_OVERRIDDEN_DIMENSION = 'org.parisoft.noop.PARAMETER_OVERRIDDEN_DIMENSION'
	public static val METHOD_DUPLICITY = 'org.parisoft.noop.METHOD_DUPLICITY'
	public static val METHOD_DIMENSIONAL_VOID = 'org.parisoft.noop.METHOD DIMENSIONAL_VOID'
	public static val METHOD_STORAGE_TYPE = 'org.parisoft.noop.METHOD_STORAGE_TYPE'
	public static val METHOD_OVERRIDDEN_TYPE = 'org.parisoft.noop.METHOD_OVERRIDDEN_TYPE'
	public static val METHOD_OVERRIDDEN_DIMENSION = 'org.parisoft.noop.METHOD_OVERRIDDEN_DIMENSION'
	public static val METHOD_IRQ_NON_STATIC = 'org.parisoft.noop.METHOD_IRQ_NON_STATIC'
	public static val METHOD_IRQ_PARAMS = 'org.parisoft.noop.METHOD_IRQ_PARAMS'
	public static val RETURN_UNBOUNDED_DIMENSION = 'org.parisoft.noop.RETURN_UNBOUNDED_DIMENSION'
	public static val RETURN_INCONSISTENT_DIMENSION = 'org.parisoft.noop.RETURN_INCONSISTENT_DIMENSION'
	public static val STATEMENT_UNREACHABLE = 'org.parisoft.noop.STATEMENT_UNREACHABLE'
	public static val IF_CONDITION_TYPE = 'org.parisoft.noop.IF_CONDITION_TYPE'
	public static val IF_CONSTANT_CONDITION = 'org.parisoft.noop.IF_CONSTANT_CONDITION'
	public static val IF_EMPTY_BODY = 'org.parisoft.noop.IF_EMPTY_BODY'
	public static val ELSE_EMPTY_BODY = 'org.parisoft.noop.ELSE_EMPTY_BODY'
	public static val FOR_CONSTANT_CONDITION = 'org.parisoft.noop.FOR_CONSTANT_CONDITION'
	public static val BREAK_CONTAINER = 'org.parisoft.noop.BREAK_CONTAINER'
	public static val CONTINUE_CONTAINER = 'org.parisoft.noop.CONTINUE_CONTAINER'
	public static val ASM_REFERENCE = 'org.parisoft.noop.ASM_REFERENCE'
	public static val EXPRESSION_SIDE_EFFECT = 'org.parisoft.noop.EXPRESSION_SIDE_EFFECT'
	public static val ASSIGN_LEFT_SIDE = 'org.parisoft.noop.ASSIGN_LEFT_SIDE'
	public static val ASSIGN_TO_CONSTANT_OR_ROM = 'org.parisoft.noop.ASSIGN_TO_CONSTANT_OR_ROM'
	public static val ASSIGN_VALUE_TYPE = 'org.parisoft.noop.ASSIGN_VALUE_TYPE'
	public static val ASSIGN_VALUE_DIMENSION = 'org.parisoft.noop.ASSIGN_VALUE_DIMENSION'
	public static val ASSIGN_TYPE = 'org.parisoft.noop.ASSIGN_TYPE'
	public static val OR_TYPES = 'org.parisoft.noop.OR_TYPES'
	public static val OR_DIMENSIONS = 'org.parisoft.noop.OR_DIMENSIONS'
	public static val AND_TYPES = 'org.parisoft.noop.AND_TYPES'
	public static val AND_DIMENSIONS = 'org.parisoft.noop.AND_DIMENSIONS'
	public static val BOR_TYPES = 'org.parisoft.noop.BOR_TYPES'
	public static val BOR_DIMENSIONS = 'org.parisoft.noop.BOR_DIMENSIONS'
	public static val BAND_TYPES = 'org.parisoft.noop.BAND_TYPES'
	public static val BAND_DIMENSIONS = 'org.parisoft.noop.BAND_DIMENSIONS'
	public static val EQ_TYPES = 'org.parisoft.noop.EQ_TYPES'
	public static val EQ_DIMENSIONS = 'org.parisoft.noop.EQ_DIMENSIONS'
	public static val NE_TYPES = 'org.parisoft.noop.NE_TYPES'
	public static val NE_DIMENSIONS = 'org.parisoft.noop.NE_DIMENSIONS'
	public static val LT_TYPES = 'org.parisoft.noop.LT_TYPES'
	public static val LT_DIMENSIONS = 'org.parisoft.noop.LT_DIMENSIONS'
	public static val LE_TYPES = 'org.parisoft.noop.LE_TYPES'
	public static val LE_DIMENSIONS = 'org.parisoft.noop.LE_DIMENSIONS'
	public static val GT_TYPES = 'org.parisoft.noop.GT_TYPES'
	public static val GT_DIMENSIONS = 'org.parisoft.noop.GT_DIMENSIONS'
	public static val GE_TYPES = 'org.parisoft.noop.GE_TYPES'
	public static val GE_DIMENSIONS = 'org.parisoft.noop.GE_DIMENSIONS'
	public static val LSHIFT_TYPES = 'org.parisoft.noop.LSHIFT_TYPES'
	public static val LSHIFT_DIMENSIONS = 'org.parisoft.noop.LSHIFT_DIMENSIONS'
	public static val RSHIFT_TYPES = 'org.parisoft.noop.RSHIFT_TYPES'
	public static val RSHIFT_DIMENSIONS = 'org.parisoft.noop.RSHIFT_DIMENSIONS'
	public static val ADD_TYPES = 'org.parisoft.noop.ADD_TYPES'
	public static val ADD_DIMENSIONS = 'org.parisoft.noop.ADD_DIMENSIONS'
	public static val SUB_TYPES = 'org.parisoft.noop.SUB_TYPES'
	public static val SUB_DIMENSIONS = 'org.parisoft.noop.SUB_DIMENSIONS'
	public static val MUL_TYPES = 'org.parisoft.noop.MUL_TYPES'
	public static val MUL_DIMENSIONS = 'org.parisoft.noop.MUL_DIMENSIONS'
	public static val DIV_TYPES = 'org.parisoft.noop.DIV_TYPES'
	public static val DIV_DIMENSIONS = 'org.parisoft.noop.DIV_DIMENSIONS'
	public static val MOD_TYPES = 'org.parisoft.noop.MOD_TYPES'
	public static val MOD_DIMENSIONS = 'org.parisoft.noop.MOD_DIMENSIONS'
	public static val CPL_TYPE = 'org.parisoft.noop.CPL_TYPE'
	public static val CPL_DIMENSION = 'org.parisoft.noop.CPL_DIMENSION'
	public static val NOT_TYPE = 'org.parisoft.noop.NOT_TYPE'
	public static val NOT_DIMENSION = 'org.parisoft.noop.NOT_DIMENSION'
	public static val NEG_TYPE = 'org.parisoft.noop.NEG_TYPE'
	public static val NEG_DIMENSION = 'org.parisoft.noop.NEG_DIMENSION'
	public static val POS_TYPE = 'org.parisoft.noop.POS_TYPE'
	public static val POS_DIMENSION = 'org.parisoft.noop.POS_DIMENSION'
	public static val INC_TYPE = 'org.parisoft.noop.INC_TYPE'
	public static val INC_DIMENSION = 'org.parisoft.noop.INC_DIMENSION'
	public static val DEC_TYPE = 'org.parisoft.noop.DEC_TYPE'
	public static val DEC_DIMENSION = 'org.parisoft.noop.DEC_DIMENSION'
	public static val INSTANCEOF_TYPES = 'org.parisoft.noop.INSTANCEOF_TYPES'
	public static val INSTANCEOF_CONSTANT_RESULT = 'org.parisoft.noop.INSTANCEOF_CONSTANT_RESULT'
	public static val CAST_TYPE = 'org.parisoft.noop.CAST_TYPE'
	public static val CAST_DIMENSION = 'org.parisoft.noop.CAST_DIMENSION'
	public static val BYTE_LITERAL_OVERFLOW = 'org.parisoft.noop.BYTE_LITERAL_OVERFLOW'
	public static val STRING_EMPTY = 'org.parisoft.noop.STRING_EMPTY'
	public static val STRING_FILE_NOT_FOUND = 'org.parisoft.noop.STRING_FILE_NOT_FOUND'
	public static val STRING_FILE_NON_ROM = 'org.parisoft.noop.STRING_FILE_NON_ROM'
	public static val STRING_FILE_NON_VARIABLE = 'org.parisoft.noop.STRING_FILE_NON_VARIABLE'
	public static val ARRAY_CONSTANT = 'org.parisoft.noop.ARRAY_CONSTANT'
	public static val ARRAY_LENGTH = 'org.parisoft.noop.ARRAY_LENGTH'
	public static val THIS_CONTEXT = 'org.parisoft.noop.THIS_CONTEXT'
	public static val SUPER_CONTEXT = 'org.parisoft.noop.SUPER_CONTEXT'
	public static val NEW_INSTANCE_TYPE = 'org.parisoft.noop.NEW_INSTANCE_TYPE'
	public static val NEW_INSTANCE_DIMENSION = 'org.parisoft.noop.NEW_INSTANCE_DIMENSION'
	public static val CONSTRUCTOR_FIELD_TYPE = 'org.parisoft.noop.CONSTRUCTOR_FIELD_TYPE'
	public static val CONSTRUCTOR_FIELD_DIMENSION = 'org.parisoft.noop.CONSTRUCTOR_FIELD_DIMENSION'
	public static val MEMBER_SELECT_VISIBILITY = 'org.parisoft.noop.MEMBER_SELECT_VISIBILITY'
	public static val MEMBER_SELECT_DIMENSION = 'org.parisoft.noop.MEMBER_SELECT_DIMENSION'
	public static val MEMBER_REF_DIMENSION = 'org.parisoft.noop.MEMBER_REF_DIMENSION'
	public static val STORAGE_LOCATION = 'org.parisoft.noop.STORAGE_LOCATION'

	@Check(NORMAL)
	def classSizeOverflow(NoopClass c) {
		if (c.isMain) {
			val ini = System::currentTimeMillis
			
			val ctx = c.prepare
			val project = c.URI.project.name
			val classes = ctx.classes.values.filter[URI.project?.name == project]
			
			println('''Prepare = «System::currentTimeMillis - ini»ms''')

			classes.filter[sizeOf > 0x100].forEach [
				error('''Class «name» size is «sizeOf» bytes which overflows the maximum of 256 bytes''', it,
					NOOP_CLASS__NAME, CLASS_SIZE_OVERFLOW)
			]
		}
	}

	@Check
	def classRecursiveHierarchy(NoopClass c) {
		if (c.superClass == c || c.superClasses.drop(1).exists[isInstanceOf(c)]) {
			error('Recursive hierarchy is not allowed', NOOP_CLASS__SUPER_CLASS, CLASS_RECURSIVE_HIERARCHY, c.name)
		}
	}

	@Check
	def classSuperType(NoopClass c) {
		if (c.superClass?.isVoid) {
			error('''«TypeSystem::LIB_VOID» cannot be extended''', NOOP_CLASS__SUPER_CLASS, CLASS_SUPERCLASS_TYPE)
		}
	}

	@Check
	def classFileName(NoopClass c) {
		if (c.URI.trimFragment.trimFileExtension.lastSegment != c.name) {
			error('''Class and file must have the same name''', NOOP_CLASS__NAME, CLASS_FILE_NAME)
		}
	}

	@Check
	def fieldTypeSameHierarchy(Variable v) {
		if (v.isField && v.isNonStatic) {
			val varClass = v.containerClass
			val varType = v.typeOf
			val sameHierarchy = varClass.isInstanceOf(varType) || varType.isInstanceOf(varClass) ||
				varType.allFieldsBottomUp.exists[varClass.isInstanceOf(typeOf)]

			if (sameHierarchy) {
				error(
					'Type of non-static fields cannot be nor contains fields on the same hierarchy of the field\'s class',
					VARIABLE__VALUE, FIELD_TYPE_SAME_HIERARCHY)
			}
		}
	}

	@Check
	def fieldCrossReference(Variable v) {
		if (v.isField && v.isNonStatic) {
			val varClass = v.containerClass

			if (v.typeOf.allFieldsBottomUp.exists[typeOf.isSubclassOf(varClass)]) {
				error('Cross-reference field is not allowed', VARIABLE__VALUE, FIELD_CROSS_REFERENCE)
			}
		}
	}

	@Check
	def fieldStorage(Variable v) {
		if (v.isField && v.isNonStatic && v.storage !== null) {
			error('Non-static fields cannot be tagged', MEMBER__STORAGE, FIELD_STORAGE)
		}
	}

	@Check
	def fieldDuplicity(Variable v) {
		if (v.isField) {
			val duplicates = v.containerClass.declaredFields.takeWhile[it != v].filter[it.name == v.name].toList

			if (duplicates.isNotEmpty) {
				duplicates += v
				duplicates.forEach [
					error('''Field «v.name» is duplicated''', it, MEMBER__NAME, FIELD_DUPLICITY)
				]
			}
		}
	}

	@Check
	def fieldOverriddenType(Variable v) {
		if (v.isField) {
			val overridden = v.containerClass.allFieldsTopDown.findFirst[v.isOverrideOf(it)]

			if (overridden !== null) {
				val overriddenType = overridden.typeOf

				if (v.typeOf.isNotEquals(overriddenType)) {
					error('''Field «v.name» must have the same «overriddenType.name» type of the overridden field''',
						VARIABLE__VALUE, FIELD_OVERRIDDEN_TYPE)
				}
			}
		}
	}

	@Check
	def fieldOverriddenDimension(Variable v) {
		if (v.isField && v.isNonROM) {
			val overridden = v.containerClass.superClass.allFieldsTopDown.findFirst[v.isOverrideOf(it)]

			if (overridden !== null) {
				val overrideDimension = overridden.dimensionOf

				if (v.dimensionOf != overrideDimension) {
					if (overrideDimension.isEmpty) {
						error('''Field «v.name» must be a non-array as the overridden field''', MEMBER__NAME,
							FIELD_OVERRIDDEN_DIMENSION)
					} else {
						error('''Field «v.name» must be an array of length «overrideDimension.map['''[«it»]'''].join» as the overridden field''',
							MEMBER__NAME, FIELD_OVERRIDDEN_DIMENSION)
					}
				}
			}
		}
	}

	@Check
	def staticFieldContainer(Variable v) {
		if (v.isStatic && v.isNonField) {
			error('''«IF v.isParameter»Parameters«ELSE»Local variables«ENDIF» cannot be declared as static''',
				MEMBER__NAME, STATIC_FIELD_CONTAINER)
		}
	}

	@Check
	def staticFieldStorageType(Variable v) {
		if (v.isStatic && v.storage?.type == StorageType::INLINE) {
			error('''Fields cannot be tagged as «v.storage.type.literal.substring(1)»''', MEMBER__STORAGE,
				STATIC_FIELD_STORAGE_TYPE)
		}
	}

	@Check
	def romFieldNonConstant(Variable v) {
		if (v.isROM && v.isNonConstant) {
			error('''Fields tagged as «v.storage.type.literal.substring(0)» must be constant''', v, null,
				ROM_FIELD_NON_CONSTANT, v.name, v.storage.type.literal)
		}
	}

	@Check
	def inesFieldNonConstant(Variable v) {
		if (v.isINesHeader && v.isNonConstant) {
			error('''Fields tagged as «v.storage.type.literal.substring(0)» must be constant''', v, null,
				INES_FIELD_NON_CONSTANT, v.name, v.storage.type.literal)
		}
	}

	@Check
	def inesFieldDimension(Variable v) {
		if (v.isINesHeader && v.dimensionOf.isNotEmpty) {
			error('''Fields tagged as «v.storage.type.literal.substring(0)» cannot be an array''', v, null,
				INES_FIELD_DIMENSION)
		}
	}

	@Check
	def constantFieldType(Variable v) {
		if (v.isConstant && v.typeOf.isNonPrimitive) {
			error('''Type of constant fields must be «TypeSystem::LIB_PRIMITIVES.join(', ')»''', VARIABLE__VALUE,
				CONSTANT_FIELD_TYPE)
		}
	}

	@Check
	def constantFieldDimension(Variable v) {
		if (v.isConstant && v.dimensionOf.isNotEmpty && v.storage === null) {
			error('''Missing «StorageType::PRGROM.literal» or «StorageType::CHRROM.literal» tag''', VARIABLE__DIMENSION,
				CONSTANT_FIELD_DIMENSION, v.name)
		}
	}

	@Check
	def constantFieldStorage(Variable v) {
		if (v.isConstant && v.storage !== null && v.isNonROM && v.isNonINesHeader) {
			error('''Constant fields cannot be tagged as «v.storage.type.literal.substring(1)»''', MEMBER__STORAGE,
				CONSTANT_FIELD_STORAGE, v.name, v.storage.type.literal.substring(0))
		}
	}

	@Check
	def constantFieldValue(Variable v) {
		if (v.isConstant && v.value.isNonConstant) {
			error('Constant fields must be declared with a constant value', VARIABLE__VALUE, CONSTANT_FIELD_VALUE)
		}
	}

	@Check
	def variableVoidType(Variable v) {
		if (v.isNonParameter && v.typeOf.isVoid) {
			error('''«TypeSystem::LIB_VOID» is not a valid type for «IF v.isField»fields«ELSE»variables«ENDIF»''',
				VARIABLE__VALUE, VARIABLE_VOID_TYPE)
		}
	}

	@Check
	def variableDuplicity(Variable v) {
		if (v.isNonField && v.isNonParameter) {
			val duplicates = v.searchDuplicatesOn(v.eContainer).toList

			if (duplicates.isNotEmpty) {
				duplicates += v
				duplicates.forEach [
					error('''Variable «name» is duplicated''', it, MEMBER__NAME, VARIABLE_DUPLICITY)
				]
			}
		}
	}

	@Check
	def variableNeverUsed(Variable v) {
		if (v.isNonField && v.isNonParameter) {
			if (v.getContainerOfType(Method).getAllContentsOfType(MemberSelect).forall[member != v] &&
				v.getContainerOfType(Method).getAllContentsOfType(MemberRef).forall[member != v]) {
				warning('''Variable «v.name» is never used locally''', MEMBER__NAME, VARIABLE_NEVER_USED)
			}
		}
	}

	@Check
	def variableDimension(Variable v) {
		if (v?.value.isUnbounded && v?.value?.dimensionOf?.size > 0) {
			error('''«IF v.isField»Fields«ELSE»Variables«ENDIF» cannot be declared with an unbounded array''',
				VARIABLE__VALUE, VARIABLE_DIMENSION)
		}
	}

	@Check
	def parameterVoidType(Variable v) {
		if (v.isParameter && v.type.isVoid) {
			error('''«TypeSystem::LIB_VOID» is not a valid type for parameters''', VARIABLE__TYPE, PARAMETER_VOID_TYPE)
		}
	}

	@Check
	def parameterStorageType(Variable v) {
		if (v.isParameter && v.storage?.type != StorageType::ZP) {
			error('''Parameters cannot be tagged as «v.storage.type.literal.substring(1)»''', MEMBER__STORAGE,
				PARAMETER_STORAGE_TYPE)
		}
	}

	@Check
	def parameterDuplicity(Variable v) {
		if (v.isParameter) {
			val duplicates = v.getContainerOfType(Method).params.takeWhile[it != v].filter[it.name == v.name].toList

			if (duplicates.isNotEmpty) {
				duplicates += v
				duplicates.forEach [
					error('''Parameter «name» is duplicated''', it, MEMBER__NAME, PARAMETER_DUPLICITY)
				]
			}
		}
	}

	@Check
	def parameterDimensionValue(Variable v) {
		if (v.isParameter) {
			v.dimension.forEach [
				try {
					val value = value?.valueOf as Integer ?: 0

					if (value < 0) {
						error('Length must be a positive number', it, null, NEW_INSTANCE_DIMENSION)
					}
				} catch (NonConstantExpressionException e) {
					error('Length must be a constant expression', it, null, NEW_INSTANCE_DIMENSION)
				} catch (ClassCastException e) {
					error('Length must be numeric', it, null, NEW_INSTANCE_DIMENSION)
				}
			]
		}
	}

	@Check
	def parameterDimensionConsistence(Variable v) {
		if (v.isParameter) {
			if (!(v.dimension.forall[value === null] || v.dimension.forall[value !== null])) {
				v.dimension.filter[value === null].forEach [
					error('''Length expression is missing''', it, null, PARAMETER_DIMENSION_CONSISTENCE)
				]
			}
		}
	}

	@Check
	def parameterOverriddenDimension(Variable v) {
		val m = v.eContainer

		if (m instanceof Method) {
			val overriddenMethod = m.containerClass.allMethodsTopDown.findFirst[m.isOverrideOf(it)]

			if (overriddenMethod !== null) {
				val overridden = overriddenMethod.params.get(m.params.indexOf(v))

				for (i : 0 ..< v.dimension.size) {
					val paramLen = v.dimension.get(i).value
					val overriddenLen = overridden.dimension.get(i).value

					if (paramLen === null && overriddenLen !== null) {
						error('''Lenght must be «overriddenLen.valueOf» as the overridden parameter''',
							v.dimension.get(i), null, PARAMETER_OVERRIDDEN_DIMENSION)
					} else if (paramLen !== null && overriddenLen === null) {
						error('Length must be omitted as the overridden parameter', paramLen, null,
							PARAMETER_OVERRIDDEN_DIMENSION)
					} else if (paramLen !== null && paramLen.isConstant && overriddenLen.isConstant &&
						paramLen.valueOf != overriddenLen.valueOf) {
						error('''Lenght must be «overriddenLen.valueOf» as the overridden parameter''', paramLen, null,
							PARAMETER_OVERRIDDEN_DIMENSION)
					}
				}
			}
		}
	}

	@Check
	def methodDuplicity(Method m) {
		val duplicates = m.containerClass.declaredMethods.takeWhile[it != m].filter [
			it.name == m.name
		].filter [
			it.params.size == m.params.size
		].filter [
			for (i : 0 ..< params.size) {
				val p1 = it.params.get(i)
				val p2 = m.params.get(i)

				if (p1.type.isNotEquals(p2.type)) {
					return false
				}

				if (p1.dimensionOf.size != p2.dimensionOf.size) {
					return false
				}
			}

			true
		].toList

		if (duplicates.isNotEmpty) {
			duplicates += m
			duplicates.forEach [
				error('''Method «name» is duplicated''', it, MEMBER__NAME, METHOD_DUPLICITY)
			]
		}
	}

	@Check
	def methodDimensionalVoid(Method m) {
		if (m.typeOf.isVoid && m.dimensionOf.isNotEmpty) {
			error('''«TypeSystem::LIB_VOID» methods must return a non-array value''', MEMBER__NAME,
				METHOD_DIMENSIONAL_VOID)
		}
	}

	@Check
	def methodStorageType(Method m) {
		if (m.storage !== null && m.isNonROM && m.isNonInline && m.isNonIrqImpl) {
			error('''Methods cannot be tagged as «m.storage.type.literal.substring(0)»''', MEMBER__STORAGE,
				METHOD_STORAGE_TYPE, m.name, m.storage.type.literal)
		}
	}

	@Check
	def methodOverriddenType(Method m) {
		val overridden = m.containerClass.allMethodsTopDown.findFirst[m.isOverrideOf(it)]

		if (overridden !== null && m.typeOf.isNonSubclassOf(overridden.typeOf)) {
			error('''Method «m.name» must return the same «overridden.typeOf.name» type or a subtype returned by the overridden method''',
				MEMBER__NAME, METHOD_OVERRIDDEN_TYPE)
		}
	}

	@Check
	def methodOverriddenDimension(Method m) {
		val overridden = m.containerClass.allMethodsTopDown.findFirst[m.isOverrideOf(it)]

		if (overridden !== null) {
			val methodDimension = m.dimensionOf
			val overriddenDimension = overridden.dimensionOf

			if (methodDimension != overriddenDimension) {
				if (overriddenDimension.isEmpty) {
					error('''Method «m.name» must return a non-array value as the overridden method''', MEMBER__NAME,
						METHOD_OVERRIDDEN_DIMENSION)
				} else {
					error('''Method «m.name» must return an array of length «overriddenDimension.map['''[«it»]'''].join» as returned by the overridden method''',
						MEMBER__NAME, METHOD_OVERRIDDEN_DIMENSION)
				}
			}
		}
	}

	@Check
	def methodIrqNonStatic(Method m) {
		if (m.isIrqImpl && m.isNonStatic) {
			error('''Methods tagged as «m.storage.type.literal.substring(0)» must be static''', m, null,
				METHOD_IRQ_NON_STATIC, m.name, m.storage.type.literal)
		}
	}
	
	@Check
	def methodIrqParams(Method m) {
		if (m.isIrqImpl && m.params.isNotEmpty) {
			error('''Methods tagged as «m.storage.type.literal.substring(0)» must be non-args''', m, null,
				METHOD_IRQ_PARAMS, m.name, m.storage.type.literal)
		}
	}

	@Check
	def returnUnboundedDimension(ReturnStatement ret) {
		if (ret.value?.isUnbounded) {
			error('Methods must return bounded arrays', RETURN_STATEMENT__VALUE, RETURN_UNBOUNDED_DIMENSION)
		}
	}

	@Check
	def returnInconsistentDimension(ReturnStatement ret) {
		val inconsistents = ret.getContainerOfType(Method).getAllContentsOfType(ReturnStatement).takeWhile [
			it != ret
		].filter [
			it?.value.dimensionOf != ret?.value.dimensionOf
		].toList

		if (inconsistents.isNotEmpty) {
			inconsistents += ret
			inconsistents.forEach [
				error('All returned arrays in a method must have the same length', it, RETURN_STATEMENT__VALUE,
					RETURN_INCONSISTENT_DIMENSION)
			]
		}
	}

	@Check
	def statementUnreachable(Statement statement) {
		val block = statement.eContainer

		if (block instanceof Block) {
			if (block.statements.takeWhile[it != statement].exists[blocker]) {
				warning('Dead code', statement, null, STATEMENT_UNREACHABLE)
			}
		}
	}

	@Check
	def ifConditionType(IfStatement ifStatement) {
		if (ifStatement.condition.typeOf.isNonBoolean) {
			error('''Ifs condition must be a «TypeSystem::LIB_BOOL» expression''', IF_STATEMENT__CONDITION,
				IF_CONDITION_TYPE)
		}
	}

	@Check
	def ifConstantCondition(IfStatement ifStatement) {
		if (ifStatement.condition.isConstant) {
			val condition = ifStatement.condition.valueOf

			if (condition instanceof Boolean) {
				warning('''If's condition always evaluate to «ifStatement.condition.valueOf»''',
					IF_STATEMENT__CONDITION, IF_CONSTANT_CONDITION)

				if (condition) {
					var nextElse = ifStatement.^else

					while (nextElse !== null) {
						if (nextElse.body !== null) {
							warning('Dead code', nextElse.body, null, IF_CONSTANT_CONDITION)
						} else if (nextElse.^if !== null) {
							warning('Dead code', nextElse.^if.body, null, IF_CONSTANT_CONDITION)
						}

						nextElse = nextElse.^if?.^else
					}
				} else {
					warning('Dead code', ifStatement.body, null, IF_CONSTANT_CONDITION)
				}
			}
		}
	}

	@Check
	def ifEmptyBody(IfStatement ifStatement) {
		if (ifStatement.body.statements.isEmpty) {
			warning('Useless if statement', IF_STATEMENT__NAME, IF_EMPTY_BODY)
		}
	}

	@Check
	def elseEmptyBody(ElseStatement elseStatement) {
		if (elseStatement.body?.statements?.isEmpty) {
			warning('Useless else statement', ELSE_STATEMENT__NAME, ELSE_EMPTY_BODY)
		}
	}

	@Check
	def forConstantCondition(ForStatement forStatement) {
		if (forStatement.condition?.isConstant) {
			val condition = forStatement.condition.valueOf

			if (condition instanceof Boolean && (condition as Boolean) == false) {
				warning('For\'s condition always evaluate to false', FOR_STATEMENT__CONDITION, FOR_CONSTANT_CONDITION)
				warning('Dead code', forStatement.body, null, FOR_CONSTANT_CONDITION)
			}
		}
	}

	@Check
	def breakContainer(BreakStatement break) {
		if (break.getContainerOfType(ForStatement) === null && break.getContainerOfType(ForeverStatement) === null) {
			error('Break statement must be inside a loop statement', BREAK_STATEMENT__NAME, BREAK_CONTAINER)
		}
	}

	@Check
	def continueContainer(ContinueStatement continue) {
		if (continue.getContainerOfType(ForStatement) === null &&
			continue.getContainerOfType(ForeverStatement) === null) {
			error('Continue statement must be inside a loop statement', CONTINUE_STATEMENT__NAME, CONTINUE_CONTAINER)
		}
	}

	@Check
	def asmReference(AsmStatement asm) {
		asm.vars.reject[it instanceof MemberSelect || it instanceof MemberRef || isThisOrSuper].forEach [
			error('Expected a variable, field or method reference', it, null, ASM_REFERENCE)
		]
	}

	@Check
	def expressionSideEffect(Expression expr) {
		if (expr.eContainer instanceof Block) {
			val invalid = switch (expr) {
				AssignmentExpression: false
				DecExpression: false
				IncExpression: false
				MemberSelect: expr.member instanceof Variable
				MemberRef: expr.member instanceof Variable
				default: true
			}

			if (invalid) {
				error('This expression is not allowed here, since it doesn\'t cause any side effects', expr, null,
					EXPRESSION_SIDE_EFFECT)
			}
		}
	}

	@Check
	def assignLeftSide(AssignmentExpression assignment) {
		val left = assignment.left
		val member = switch (left) {
			MemberSelect: left.member
			MemberRef: left.member
		}

		if (member === null || member instanceof Method) {
			error('Can only assign a value to a variable', ASSIGNMENT_EXPRESSION__LEFT, ASSIGN_LEFT_SIDE)
		}
	}

	@Check
	def assignToConstantOrRom(AssignmentExpression assignment) {
		val left = assignment.left
		val member = switch (left) {
			MemberSelect: left.member
			MemberRef: left.member
		}

		if (member instanceof Variable) {
			if (member.isConstant) {
				error('Cannot assign a value to a constant field', ASSIGNMENT_EXPRESSION__LEFT,
					ASSIGN_TO_CONSTANT_OR_ROM)
			}
		}
	}

	@Check
	def assignValueDimension(AssignmentExpression assignment) {
		val left = assignment.left
		val right = assignment.right
		val leftDim = left.dimensionOf
		val rightDim = right.dimensionOf

		if (leftDim.isEmpty && rightDim.isNotEmpty) {
			error('''Cannot assign an array value to a non-array variable''', ASSIGNMENT_EXPRESSION__RIGHT,
				ASSIGN_VALUE_DIMENSION)
		} else if (leftDim.isNotEmpty && rightDim.isEmpty) {
			error('''Cannot assign a non-array value to an array variable''', ASSIGNMENT_EXPRESSION__RIGHT,
				ASSIGN_VALUE_DIMENSION)
		} else if (leftDim.size != rightDim.size) {
			val leftStr = left.dimensionOf.map['''[«it ?: '?'»]'''].join
			val rightStr = right.dimensionOf.map['''[«it ?: '?'»]'''].join
			error('''Cannot assign a value of type «right.typeOf.name»«rightStr» to a variable of type «left.typeOf.name»«leftStr»''',
				ASSIGNMENT_EXPRESSION__RIGHT, ASSIGN_VALUE_DIMENSION)
		}
	}

	@Check
	def assignType(AssignmentExpression assignment) {
		val type = assignment.assignment
		val left = assignment.left
		val right = assignment.right
		val leftType = left.typeOf
		val rightType = right.typeOf

		if (type == ADD_ASSIGN || type == SUB_ASSIGN || type == MUL_ASSIGN || type == DIV_ASSIGN ||
			type == MOD_ASSIGN || type == BLS_ASSIGN || type == BRS_ASSIGN) {
			if (leftType.isNonNumeric) {
				error('''Invalid assignment to a non-numeric variable of type «leftType.name»''',
					ASSIGNMENT_EXPRESSION__ASSIGNMENT, ASSIGN_TYPE)
			} else if (left.dimensionOf.isNotEmpty) {
				error('''Invalid assignment to an array variable''', ASSIGNMENT_EXPRESSION__ASSIGNMENT, ASSIGN_TYPE)
			} else if (rightType.isNonNumeric) {
				error('''Right-hand side of assignment must be a numeric value''', ASSIGNMENT_EXPRESSION__RIGHT,
					ASSIGN_VALUE_TYPE)
			} else if (right.dimensionOf.isNotEmpty) {
				error('''Right-hand side of assignment must be a non-array value''', ASSIGNMENT_EXPRESSION__RIGHT,
					ASSIGN_VALUE_TYPE)
			}
		} else if (type == BAN_ASSIGN || type == BOR_ASSIGN) {
			if (leftType.isNonPrimitive) {
				error('''Invalid assignment to a non-«TypeSystem::LIB_PRIMITIVE.toLowerCase» variable of type «assignment.left.typeOf.name»''',
					ASSIGNMENT_EXPRESSION__ASSIGNMENT, ASSIGN_TYPE)
			} else if (left.dimensionOf.isNotEmpty) {
				error('''Invalid assignment to an array variable''', ASSIGNMENT_EXPRESSION__ASSIGNMENT, ASSIGN_TYPE)
			} else if (rightType.isNonPrimitive) {
				error('''Right-hand side of assignment must be a «TypeSystem::LIB_PRIMITIVE» value''',
					ASSIGNMENT_EXPRESSION__RIGHT, ASSIGN_VALUE_TYPE)
			} else if (right.dimensionOf.isNotEmpty) {
				error('''Right-hand side of assignment must be a non-array value''', ASSIGNMENT_EXPRESSION__RIGHT,
					ASSIGN_VALUE_TYPE)
			}
		} else if (type == ASSIGN) {
			if (left.dimensionOf.isNotEmpty && right.dimensionOf.isNotEmpty && leftType.isNotEquals(rightType)) {
				val leftDim = left.dimensionOf.map['''[«it ?: '?'»]'''].join
				val rightDim = right.dimensionOf.map['''[«it ?: '?'»]'''].join
				error('''Cannot assign a value of type «rightType.name»«rightDim» to a variable of type «leftType.name»«leftDim»''',
					ASSIGNMENT_EXPRESSION__RIGHT, ASSIGN_VALUE_TYPE)
			} else if (rightType.isNonInstanceOf(leftType)) {
				error('''Cannot assign a value of type «rightType.name» to a variable of type «leftType.name»''',
					ASSIGNMENT_EXPRESSION__RIGHT, ASSIGN_VALUE_TYPE)
			}
		}

	}

	@Check
	def orTypes(OrExpression x) {
		if (x.left.typeOf.isNonBoolean) {
			error('''Left-hand side of a Logical expression must be a «TypeSystem::LIB_BOOL» value''',
				OR_EXPRESSION__LEFT, OR_TYPES)
		}

		if (x.right.typeOf.isNonBoolean) {
			error('''Right-hand side of a Logical expression must be a «TypeSystem::LIB_BOOL» value''',
				OR_EXPRESSION__RIGHT, OR_TYPES)
		}
	}

	@Check
	def orDimensions(OrExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of a Logical expression must be a non-array value', OR_EXPRESSION__LEFT,
				OR_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Logical expression must be a non-array value', OR_EXPRESSION__RIGHT,
				OR_DIMENSIONS)
		}
	}

	@Check
	def andTypes(AndExpression x) {
		if (x.left.typeOf.isNonBoolean) {
			error('''Left-hand side of a Logical expression must be a «TypeSystem::LIB_BOOL» value''',
				AND_EXPRESSION__LEFT, AND_TYPES)
		}

		if (x.right.typeOf.isNonBoolean) {
			error('''Right-hand side of a Logical expression must be a «TypeSystem::LIB_BOOL» value''',
				AND_EXPRESSION__RIGHT, AND_TYPES)
		}
	}

	@Check
	def andDimensions(AndExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of a Logical expression must be a non-array value', AND_EXPRESSION__LEFT,
				AND_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Logical expression must be a non-array value', AND_EXPRESSION__RIGHT,
				AND_DIMENSIONS)
		}
	}

	@Check
	def bitOrTypes(BOrExpression x) {
		if (x.left.typeOf.isNonPrimitive) {
			error('''Left-hand side of a Bitwise expression must be a «TypeSystem::LIB_PRIMITIVE» value''',
				BOR_EXPRESSION__LEFT, BOR_TYPES)
		}

		if (x.right.typeOf.isNonPrimitive) {
			error('''Right-hand side of a Bitwise expression must be a «TypeSystem::LIB_PRIMITIVE» value''',
				BOR_EXPRESSION__RIGHT, BOR_TYPES)
		}
	}

	@Check
	def bitOrDimensions(BOrExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of a Bitwise expression must be a non-array value', BOR_EXPRESSION__LEFT,
				BOR_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Bitwise expression must be a non-array value', BOR_EXPRESSION__RIGHT,
				BOR_DIMENSIONS)
		}
	}

	@Check
	def bitAndTypes(BAndExpression x) {
		if (x.left.typeOf.isNonPrimitive) {
			error('''Left-hand side of a Bitwise expression must be a «TypeSystem::LIB_PRIMITIVE» value''',
				BAND_EXPRESSION__LEFT, BAND_TYPES)
		}

		if (x.right.typeOf.isNonPrimitive) {
			error('''Right-hand side of a Bitwise expression must be a «TypeSystem::LIB_PRIMITIVE» value''',
				BAND_EXPRESSION__RIGHT, BAND_TYPES)
		}
	}

	@Check
	def bitAndDimensions(BAndExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of a Bitwise expression must be a non-array value', BAND_EXPRESSION__LEFT,
				BAND_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Bitwise expression must be a non-array value', BAND_EXPRESSION__RIGHT,
				BAND_DIMENSIONS)
		}
	}

	@Check
	def eqTypes(EqualsExpression x) {
		if (x.left.typeOf.isNonPrimitive) {
			error('''Left-hand side of an Equality expression must be a «TypeSystem::LIB_PRIMITIVE» value''',
				EQUALS_EXPRESSION__LEFT, EQ_TYPES)
		}

		if (x.right.typeOf.isNonPrimitive) {
			error('''Right-hand side of an Equality expression must be a «TypeSystem::LIB_PRIMITIVE» value''',
				EQUALS_EXPRESSION__RIGHT, EQ_TYPES)
		}
	}

	@Check
	def eqDimensions(EqualsExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of an Equality expression must be a non-array value', EQUALS_EXPRESSION__LEFT,
				EQ_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of an Equality expression must be a non-array value', EQUALS_EXPRESSION__RIGHT,
				EQ_DIMENSIONS)
		}
	}

	@Check
	def neTypes(DifferExpression x) {
		if (x.left.typeOf.isNonPrimitive) {
			error('''Left-hand side of an Equality expression must be a «TypeSystem::LIB_PRIMITIVE» value''',
				DIFFER_EXPRESSION__LEFT, NE_TYPES)
		}

		if (x.right.typeOf.isNonPrimitive) {
			error('''Right-hand side of an Equality expression must be a «TypeSystem::LIB_PRIMITIVE» value''',
				DIFFER_EXPRESSION__RIGHT, NE_TYPES)
		}
	}

	@Check
	def neDimensions(DifferExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of an Equality expression must be a non-array value', DIFFER_EXPRESSION__LEFT,
				NE_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of an Equality expression must be a non-array value', DIFFER_EXPRESSION__RIGHT,
				NE_DIMENSIONS)
		}
	}

	@Check
	def ltTypes(LtExpression x) {
		if (x.left.typeOf.isNonNumeric) {
			error('Left-hand side of a Relational expression must be a Numeric value', LT_EXPRESSION__LEFT, LT_TYPES)
		}

		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of a Relational expression must be a Numeric value', LT_EXPRESSION__RIGHT, LT_TYPES)
		}
	}

	@Check
	def ltDimensions(LtExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of a Relational expression must be a non-array value', LT_EXPRESSION__LEFT,
				LT_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Relational expression must be a non-array value', LT_EXPRESSION__RIGHT,
				LT_DIMENSIONS)
		}
	}

	@Check
	def leTypes(LeExpression x) {
		if (x.left.typeOf.isNonNumeric) {
			error('Left-hand side of a Relational expression must be a Numeric value', LE_EXPRESSION__LEFT, LE_TYPES)
		}

		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of a Relational expression must be a Numeric value', LE_EXPRESSION__RIGHT, LE_TYPES)
		}
	}

	@Check
	def leDimensions(LeExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of a Relational expression must be a non-array value', LE_EXPRESSION__LEFT,
				LE_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Relational expression must be a non-array value', LE_EXPRESSION__RIGHT,
				LE_DIMENSIONS)
		}
	}

	@Check
	def gtTypes(GtExpression x) {
		if (x.left.typeOf.isNonNumeric) {
			error('Left-hand side of a Relational expression must be a Numeric value', GT_EXPRESSION__LEFT, GT_TYPES)
		}

		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of a Relational expression must be a Numeric value', GT_EXPRESSION__RIGHT, GT_TYPES)
		}
	}

	@Check
	def gtDimensions(GtExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of a Relational expression must be a non-array value', GT_EXPRESSION__LEFT,
				GT_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Relational expression must be a non-array value', GT_EXPRESSION__RIGHT,
				GT_DIMENSIONS)
		}
	}

	@Check
	def geTypes(GeExpression x) {
		if (x.left.typeOf.isNonNumeric) {
			error('Left-hand side of a Relational expression must be a Numeric value', GE_EXPRESSION__LEFT, GE_TYPES)
		}

		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of a Relational expression must be a Numeric value', GE_EXPRESSION__RIGHT, GE_TYPES)
		}
	}

	@Check
	def geDimensions(GeExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of a Relational expression must be a non-array value', GE_EXPRESSION__LEFT,
				GE_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Relational expression must be a non-array value', GE_EXPRESSION__RIGHT,
				GE_DIMENSIONS)
		}
	}

	@Check
	def leftShiftTypes(LShiftExpression x) {
		if (x.left.typeOf.isNonNumeric) {
			error('Left-hand side of a Shift expression must be a Numeric value', LSHIFT_EXPRESSION__LEFT, LSHIFT_TYPES)
		}

		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of a Shift expression must be a Numeric value', LSHIFT_EXPRESSION__RIGHT,
				LSHIFT_TYPES)
		}
	}

	@Check
	def leftShiftDimensions(LShiftExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of a Shift expression must be a non-array value', LSHIFT_EXPRESSION__LEFT,
				LSHIFT_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Shift expression must be a non-array value', LSHIFT_EXPRESSION__RIGHT,
				LSHIFT_DIMENSIONS)
		}
	}

	@Check
	def rightShiftTypes(RShiftExpression x) {
		if (x.left.typeOf.isNonNumeric) {
			error('Left-hand side of a Shift expression must be a Numeric value', RSHIFT_EXPRESSION__LEFT, RSHIFT_TYPES)
		}

		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of a Shift expression must be a Numeric value', RSHIFT_EXPRESSION__RIGHT,
				RSHIFT_TYPES)
		}
	}

	@Check
	def rightShiftDimensions(RShiftExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of a Shift expression must be a non-array value', RSHIFT_EXPRESSION__LEFT,
				RSHIFT_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Shift expression must be a non-array value', RSHIFT_EXPRESSION__RIGHT,
				RSHIFT_DIMENSIONS)
		}
	}

	@Check
	def addTypes(AddExpression x) {
		if (x.left.typeOf.isNonNumeric) {
			error('Left-hand side of an Arithmetic expression must be a Numeric value', ADD_EXPRESSION__LEFT, ADD_TYPES)
		}

		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of an Arithmetic expression must be a Numeric value', ADD_EXPRESSION__RIGHT,
				ADD_TYPES)
		}
	}

	@Check
	def addDimensions(AddExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of an Arithmetic expression must be a non-array value', ADD_EXPRESSION__LEFT,
				ADD_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of an Arithmetic expression must be a non-array value', ADD_EXPRESSION__RIGHT,
				ADD_DIMENSIONS)
		}
	}

	@Check
	def subTypes(SubExpression x) {
		if (x.left.typeOf.isNonNumeric) {
			error('Left-hand side of an Arithmetic expression must be a Numeric value', SUB_EXPRESSION__LEFT, SUB_TYPES)
		}

		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of an Arithmetic expression must be a Numeric value', SUB_EXPRESSION__RIGHT,
				SUB_TYPES)
		}
	}

	@Check
	def subDimensions(SubExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of an Arithmetic expression must be a non-array value', SUB_EXPRESSION__LEFT,
				SUB_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of an Arithmetic expression must be a non-array value', SUB_EXPRESSION__RIGHT,
				SUB_DIMENSIONS)
		}
	}

	@Check
	def mulTypes(MulExpression x) {
		if (x.left.typeOf.isNonNumeric) {
			error('Left-hand side of an Arithmetic expression must be a Numeric value', MUL_EXPRESSION__LEFT, MUL_TYPES)
		}

		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of an Arithmetic expression must be a Numeric value', MUL_EXPRESSION__RIGHT,
				MUL_TYPES)
		}
	}

	@Check
	def mulDimensions(MulExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of an Arithmetic expression must be a non-array value', MUL_EXPRESSION__LEFT,
				MUL_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of an Arithmetic expression must be a non-array value', MUL_EXPRESSION__RIGHT,
				MUL_DIMENSIONS)
		}
	}

	@Check
	def divTypes(DivExpression x) {
		if (x.left.typeOf.isNonNumeric) {
			error('Left-hand side of an Arithmetic expression must be a Numeric value', DIV_EXPRESSION__LEFT, DIV_TYPES)
		}

		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of an Arithmetic expression must be a Numeric value', DIV_EXPRESSION__RIGHT,
				DIV_TYPES)
		}
	}

	@Check
	def divDimensions(DivExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of an Arithmetic expression must be a non-array value', DIV_EXPRESSION__LEFT,
				DIV_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of an Arithmetic expression must be a non-array value', DIV_EXPRESSION__RIGHT,
				DIV_DIMENSIONS)
		}
	}

	@Check
	def modTypes(ModExpression x) {
		if (x.left.typeOf.isNonNumeric) {
			error('Left-hand side of an Arithmetic expression must be a Numeric value', MOD_EXPRESSION__LEFT, MOD_TYPES)
		}

		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of an Arithmetic expression must be a Numeric value', MOD_EXPRESSION__RIGHT,
				MOD_TYPES)
		}
	}

	@Check
	def modDimensions(ModExpression x) {
		if (x.left.dimensionOf.size > 1) {
			error('Left-hand side of an Arithmetic expression must be a non-array value', MOD_EXPRESSION__LEFT,
				MOD_DIMENSIONS)
		}

		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of an Arithmetic expression must be a non-array value', MOD_EXPRESSION__RIGHT,
				MOD_DIMENSIONS)
		}
	}

	@Check
	def cplType(ComplementExpression x) {
		if (x.right.typeOf.isNonPrimitive) {
			error('''Right-hand side of a Bitwise expression must be a «TypeSystem::LIB_PRIMITIVE» value''',
				COMPLEMENT_EXPRESSION__RIGHT, CPL_TYPE)
		}
	}

	@Check
	def cplDimension(ComplementExpression x) {
		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Bitwise expression must be a non-array value', COMPLEMENT_EXPRESSION__RIGHT,
				CPL_DIMENSION)
		}
	}

	@Check
	def notType(NotExpression x) {
		if (x.right.typeOf.isNonBoolean) {
			error('''Right-hand side of a Logical expression must be a «TypeSystem::LIB_BOOL» value''',
				NOT_EXPRESSION__RIGHT, NOT_TYPE)
		}
	}

	@Check
	def notDimension(NotExpression x) {
		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of a Logical expression must be a non-array value', NOT_EXPRESSION__RIGHT,
				NOT_DIMENSION)
		}
	}

	@Check
	def negType(SigNegExpression x) {
		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of an Arithmetic expression must be a Numeric value', SIG_NEG_EXPRESSION__RIGHT,
				NEG_TYPE)
		}
	}

	@Check
	def negDimension(SigNegExpression x) {
		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of an Arithmetic expression must be a non-array value', SIG_NEG_EXPRESSION__RIGHT,
				NEG_DIMENSION)
		}
	}

	@Check
	def posType(SigPosExpression x) {
		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of an Arithmetic expression must be a Numeric value', SIG_POS_EXPRESSION__RIGHT,
				POS_TYPE)
		}
	}

	@Check
	def posDimension(SigPosExpression x) {
		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of an Arithmetic expression must be a non-array value', SIG_POS_EXPRESSION__RIGHT,
				POS_DIMENSION)
		}
	}

	@Check
	def incType(IncExpression x) {
		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of an Arithmetic expression must be a Numeric value', INC_EXPRESSION__RIGHT,
				INC_TYPE)
		}
	}

	@Check
	def incDimension(IncExpression x) {
		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of an Arithmetic expression must be a non-array value', INC_EXPRESSION__RIGHT,
				INC_DIMENSION)
		}
	}

	@Check
	def decType(DecExpression x) {
		if (x.right.typeOf.isNonNumeric) {
			error('Right-hand side of an Arithmetic expression must be a Numeric value', DEC_EXPRESSION__RIGHT,
				DEC_TYPE)
		}
	}

	@Check
	def decDimension(DecExpression x) {
		if (x.right.dimensionOf.size > 1) {
			error('Right-hand side of an Arithmetic expression must be a non-array value', DEC_EXPRESSION__RIGHT,
				DEC_DIMENSION)
		}
	}

	@Check
	def instanceOfTypes(InstanceOfExpression x) {
		val leftType = x.left.typeOf

		if (leftType.isPrimitive || leftType.isVoid) {
			error('''Left-hand side of an "instanceOf" expression must be an «TypeSystem::LIB_OBJECT» value''',
				INSTANCE_OF_EXPRESSION__LEFT, INSTANCEOF_TYPES)
		}

		if (x.type.isPrimitive || x.type.isVoid) {
			error('''Right-hand side of an "instanceOf" expression must be an «TypeSystem::LIB_OBJECT» type''',
				INSTANCE_OF_EXPRESSION__TYPE, INSTANCEOF_TYPES)
		}
	}

	@Check
	def instanceOfConstantValue(InstanceOfExpression x) {
		val leftType = x.left.typeOf

		if (leftType.isNonPrimitive && leftType.isNonVoid && x.type.isNonPrimitive && x.type.isNonVoid) {
			if (leftType.isInstanceOf(x.type)) {
				warning('Expression always evaluates to true', x, null, INSTANCEOF_CONSTANT_RESULT)
			} else if (x.type.isNonInstanceOf(leftType)) {
				warning('Expression always evaluates to false', x, null, INSTANCEOF_CONSTANT_RESULT)
			}
		}
	}

	@Check
	def castType(CastExpression x) {
		if (x.left.typeOf.isVoid || x.type.isVoid) {
			error('''«x.left.typeOf.name» cannot be cast to «x.type.name»''', x, null, CAST_TYPE)
		}
	}

	@Check
	def castDimension(CastExpression cast) {
		val left = cast.left
		val leftType = left.typeOf
		val leftDim = left.dimensionOf
		val leftMember = switch (left) {
			MemberRef: left.member
			MemberSelect: left.member
		}

		if (leftMember?.isUnbounded) {
			val leftString = '''«leftType.name»«leftDim.map['[?]'].join»'''
			val castString = '''«cast.type.name»«cast.dimension.map['''[«value?.valueOf»]'''].join»'''
			error('''«leftString» cannot be cast to «castString»''', cast, null, CAST_DIMENSION)
		} else if (leftDim.size > 0 || cast.dimension.size > 0) {
			val leftLength = leftDim.reduce[a, b|a * b] ?: 1
			val castLength = cast.dimension.map [
				try {
					value?.valueOf as Integer ?: 1
				} catch (NonConstantExpressionException e) {
					error('Array length must be a constant expression', it, null, CAST_DIMENSION)
					1
				}
			].reduce[a, b|a * b] ?: 1

			if (leftLength != castLength ||
				(leftType.isPrimitive && cast.type.isPrimitive && leftType.sizeOf != cast.type.sizeOf) ||
				((leftType.isNonPrimitive || cast.type.isNonPrimitive) && leftType.isNotEquals(cast.type))) {
				val leftString = '''«leftType.name»«leftDim.map['''[«it»]'''].join»'''
				val castString = '''«cast.type.name»«cast.dimension.map['''[«value?.valueOf»]'''].join»'''
				error('''«leftString» cannot be cast to «castString»''', cast, null, CAST_DIMENSION)
			}
		}
	}

	// @Check: Not called cause its normalized during conversion
	def byteLiteralOverflow(ByteLiteral b) {
		if (b.value > TypeSystem::MAX_UINT) {
			warning('''Value overflows the maximum numeric value of «TypeSystem::MAX_UINT»''', BYTE_LITERAL__VALUE,
				BYTE_LITERAL_OVERFLOW)
		} else if (b.value < TypeSystem::MIN_INT) {
			warning('''Value underflows the minimum numeric value of «TypeSystem::MIN_INT»''', BYTE_LITERAL__VALUE,
				BYTE_LITERAL_OVERFLOW)
		}
	}

	@Check
	def stringEmpty(StringLiteral s) {
		if (s.value.isEmpty) {
			error('String cannot be empty', STRING_LITERAL__VALUE, STRING_EMPTY)
		}
	}

	@Check
	def stringFileNotFound(StringLiteral s) {
		if (s.isFileInclude) {
			val file = s.toFile

			if (!file.exists) {
				error('''File «file.name» not found on /res folder''', STRING_LITERAL__VALUE, STRING_FILE_NOT_FOUND)
			}

			val v = s.getContainerOfType(Variable)

			if (v === null) {
				error('Files can only be referenced on variables declaration', STRING_LITERAL__VALUE,
					STRING_FILE_NON_VARIABLE)
			} else if (v.isNonROM && v.isNonConstant) {
				error('''Variable «v.name» must be tagged with «StorageType::PRGROM.literal» or «StorageType::CHRROM.literal»''',
					v, null, STRING_FILE_NON_ROM, v.name)
			}
		}
	}

	@Check
	def array(ArrayLiteral a) {
		if (a.values.isEmpty) {
			error('Array cannot be empty', a, null, ARRAY_LENGTH)
		} else {
			a.values.map [
				try {
					valueOf
				} catch (NonConstantExpressionException e) {
					error('Array element must be a constant expression', it, null, ARRAY_CONSTANT)
					null
				}
			].filterNull.reduce [ a1, a2 |
				if (a1.length != a2.length || a1.depth != a2.depth) {
					error('All array elements of an array must have the same length', a, null, ARRAY_LENGTH)
				}

				a1
			]
		}
	}

	@Check
	def thisContext(This t) {
		val method = t.getContainerOfType(Method)

		if (method === null || method.isStatic) {
			error('Access to "this" can only be made inside a non-static method', t, null, THIS_CONTEXT)
		}
	}

	@Check
	def superContext(Super s) {
		val method = s.getContainerOfType(Method)

		if (method === null || method.isStatic) {
			error('Access to "super" can only be made inside a non-static method', s, null, THIS_CONTEXT)
		}
	}

	@Check
	def newInstanceType(NewInstance n) {
		if (n.type.isVoid) {
			error('''«TypeSystem::LIB_VOID» cannot be instantiated''', n, null, NEW_INSTANCE_TYPE)
		}
	}

	@Check
	def newInstanceDimension(NewInstance n) {
		n.dimension.forEach [
			try {
				val value = value?.valueOf as Integer ?: 0

				if (value == 0) {
					error('Array cannot be empty', it, null, NEW_INSTANCE_DIMENSION)
				} else if (value < 0) {
					error('Array length must be a positive number', it, null, NEW_INSTANCE_DIMENSION)
				}
			} catch (NonConstantExpressionException e) {
				error('Array length must be a constant expression', it, null, NEW_INSTANCE_DIMENSION)
			} catch (ClassCastException e) {
				error('Array length must be numeric', it, null, NEW_INSTANCE_DIMENSION)
			}
		]
	}

	@Check
	def constructorFieldType(ConstructorField field) {
		if (field.value?.typeOf?.isNonInstanceOf(field.variable.typeOf)) {
			error('''Cannot assign a value of type «field.value.typeOf.name» to a field of type «field.variable.typeOf.name»''',
				CONSTRUCTOR_FIELD__VALUE, CONSTRUCTOR_FIELD_TYPE)
		}
	}

	@Check
	def constructorFieldDimension(ConstructorField field) {
		val leftDim = field.variable.dimensionOf
		val rightDim = field.value?.dimensionOf ?: newArrayList

		if (leftDim.isEmpty && rightDim.isNotEmpty) {
			error('''Cannot assign an array value to a non-array field''', CONSTRUCTOR_FIELD__VALUE,
				CONSTRUCTOR_FIELD_DIMENSION)
		} else if (leftDim.isNotEmpty && rightDim.isEmpty) {
			error('''Cannot assign a non-array value to an array field''', CONSTRUCTOR_FIELD__VALUE,
				CONSTRUCTOR_FIELD_DIMENSION)
		} else if (leftDim.size != rightDim.size) {
			error('''Cannot assign an array value to an array field with incompatible dimensions''',
				CONSTRUCTOR_FIELD__VALUE, CONSTRUCTOR_FIELD_DIMENSION)
		}
	}

	@Check
	def memberSelectVisibility(MemberSelect select) {
		if (select.member.isNonAccessibleFrom(select)) {
			error('''Field «select.member.name» is not visible''', MEMBER_SELECT__MEMBER, MEMBER_SELECT_VISIBILITY)
		}
	}

	@Check
	def memberSelectDimension(MemberSelect select) {
		select.indexes.drop(select.member.dimensionOf.size).forEach [
			error('Invalid index', it, null, MEMBER_SELECT_DIMENSION)
		]
	}

	@Check
	def memberRefDimension(MemberRef ref) {
		ref.indexes.drop(ref.member.dimensionOf.size).forEach [
			error('Invalid index', it, null, MEMBER_REF_DIMENSION)
		]
	}

	@Check
	def storageLocation(Storage s) {
		if (s.location !== null) {
			if (s.type == StorageType::ZP || s.type == StorageType::INLINE) {
				error('''Tag «s.type.literal.substring(1)» doesn't accept locations''', STORAGE__LOCATION,
					STORAGE_LOCATION)
			} else
				try {
					if ((s.location.valueOf as Integer) < 0) {
						error('Bank must be a positive number', STORAGE__LOCATION, STORAGE_LOCATION)
					}
				} catch (NonConstantExpressionException e) {
					error('Bank must be a constant expression', STORAGE__LOCATION, STORAGE_LOCATION)
				} catch (ClassCastException e) {
					error('Bank must be a numeric expression', STORAGE__LOCATION, STORAGE_LOCATION)
				}
		}
	}

	private def int depth(Object o) {
		if (o instanceof List<?>) {
			1 + if(o.isNotEmpty) o.map[depth].max else 0
		} else if (o instanceof File) {
			1
		} else {
			0
		}
	}

	private def int length(Object o) {
		if (o instanceof List<?>) {
			o.size
		} else if (o instanceof File) {
			o.length as int
		} else {
			0
		}
	}

	private def Iterable<Variable> searchDuplicatesOn(Variable v, EObject container) {
		if (container === null) {
			return newArrayList
		}

		return switch (container) {
			Block:
				container.statements.takeWhile [
					it != v && !it.getAllContentsOfType(Variable).contains(v)
				].filter(Variable).filter[it.name == v.name]
			ForStatement:
				container.variables.takeWhile[it != v].filter(Variable).filter[it.name == v.name]
			Method:
				container.params.filter[it.name == v.name]
			default:
				newArrayList
		} + v.searchDuplicatesOn(container.eContainer)
	}

	private def isBlocker(Statement s) {
		s.isBreakContinueOrReturn || s.isInfiniteLoop || s.containsBlocker
	}

	private def isInfiniteLoop(Statement s) {
		switch (s) {
			ForStatement: {
				if (s.condition === null || s.condition.isConstant) {
					val condition = s.condition?.valueOf ?: true

					if (condition instanceof Boolean && (condition as Boolean)) {
						return s.body.getAllContentsOfType(Statement).forall[!isBreakOrReturn]
					}
				} else {
					false
				}
			}
			ForeverStatement:
				s.body.getAllContentsOfType(Statement).forall[!isBreakOrReturn]
			default:
				false
		}
	}

	private def Boolean containsBlocker(EObject s) {
		if (s === null) {
			return false
		}

		switch (s) {
			IfStatement: {
				if (s.condition.isConstant) {
					val condition = s.condition.valueOf

					if (condition instanceof Boolean) {
						if (condition) {
							s.body.statements.exists[blocker]
						} else {
							s.^else.containsBlocker
						}
					} else {
						false
					}
				} else {
					s.body.statements.exists[blocker] && s.^else.containsBlocker
				}
			}
			ElseStatement:
				if (s.body !== null) {
					s.body.statements.exists[blocker]
				} else {
					s.^if.containsBlocker
				}
			default:
				false
		}

	}

	private def isBreakContinueOrReturn(Statement s) {
		s instanceof ReturnStatement || s instanceof BreakStatement || s instanceof ContinueStatement
	}

	private def isBreakOrReturn(Statement s) {
		s instanceof ReturnStatement || s instanceof BreakStatement
	}

}
