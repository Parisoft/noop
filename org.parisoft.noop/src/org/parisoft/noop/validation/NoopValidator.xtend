/*
 * generated by Xtext 2.10.0
 */
package org.parisoft.noop.validation

import com.google.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import org.parisoft.noop.^extension.Classes
import org.parisoft.noop.^extension.Collections
import org.parisoft.noop.^extension.Expressions
import org.parisoft.noop.^extension.Members
import org.parisoft.noop.^extension.TypeSystem
import org.parisoft.noop.noop.AsmStatement
import org.parisoft.noop.noop.AssignmentExpression
import org.parisoft.noop.noop.Block
import org.parisoft.noop.noop.BreakStatement
import org.parisoft.noop.noop.ContinueStatement
import org.parisoft.noop.noop.DecExpression
import org.parisoft.noop.noop.ElseStatement
import org.parisoft.noop.noop.Expression
import org.parisoft.noop.noop.ForStatement
import org.parisoft.noop.noop.ForeverStatement
import org.parisoft.noop.noop.IfStatement
import org.parisoft.noop.noop.IncExpression
import org.parisoft.noop.noop.MemberRef
import org.parisoft.noop.noop.MemberSelect
import org.parisoft.noop.noop.Method
import org.parisoft.noop.noop.NoopClass
import org.parisoft.noop.noop.ReturnStatement
import org.parisoft.noop.noop.Statement
import org.parisoft.noop.noop.StorageType
import org.parisoft.noop.noop.Variable

import static org.parisoft.noop.noop.NoopPackage.Literals.*
import static org.parisoft.noop.noop.AssignmentType.*
import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class NoopValidator extends AbstractNoopValidator {

	@Inject extension Classes
	@Inject extension Members
	@Inject extension Expressions
	@Inject extension Collections

	public static val ISSUE_PREFIX = 'org.parisoft.noop'
	public static val CLASS_RECURSIVE_HIERARCHY = 'org.parisoft.noop.CLASS_RECURSIVE_HIERARCHY'
	public static val CLASS_SUPERCLASS_TYPE = 'org.parisoft.noop.CLASS_SUPERCLASS_TYPE'
	public static val FIELD_TYPE_SAME_HIERARCHY = 'org.parisoft.noop.FIELD_TYPE_SAME_HIERARCHY'
	public static val FIELD_STORAGE = 'org.parisoft.noop.FIELD_STORAGE'
	public static val FIELD_DUPLICITY = 'org.parisoft.noop.FIELD_DUPLICITY'
	public static val FIELD_UNDECLARED_VALUE = 'org.parisoft.noop.FIELD_UNDECLARED_VALUE'
	public static val FIELD_OVERRIDDEN_TYPE = 'org.parisoft.noop.FIELD_OVERRIDDEN_TYPE'
	public static val FIELD_OVERRIDDEN_DIMENSION = 'org.parisoft.noop.FIELD_OVERRIDDEN_DIMENSION'
	public static val STATIC_FIELD_CONTAINER = 'org.parisoft.noop.STATIC_FIELD_CONTAINER'
	public static val STATIC_FIELD_STORAGE_TYPE = 'org.parisoft.noop.STATIC_FIELD_STORAGE_TYPE'
	public static val STATIC_FIELD_ROM_TYPE = 'org.parisoft.noop.STATIC_FIELD_ROM_TYPE'
	public static val STATIC_FIELD_ROM_VALUE = 'org.parisoft.noop.STATIC_FIELD_ROM_VALUE'
	public static val STATIC_FIELD_NON_STATIC_VALUE = 'org.parisoft.noop.STATIC_FIELD_NON_STATIC_VALUE'
	public static val STATIC_FIELD_UNDECLARED_VALUE = 'org.parisoft.noop.STATIC_FIELD_UNDECLARED_VALUE'
	public static val CONSTANT_FIELD_TYPE = 'org.parisoft.noop.CONSTANT_FIELD_TYPE'
	public static val CONSTANT_FIELD_DIMENSION = 'org.parisoft.noop.CONSTANT_FIELD_DIMENSION'
	public static val CONSTANT_FIELD_STORAGE = 'org.parisoft.noop.CONSTANT_FIELD_STORAGE'
	public static val CONSTANT_FIELD_VALUE = 'org.parisoft.noop.CONSTANT_FIELD_VALUE'
	public static val VARIABLE_VOID_TYPE = 'org.parisoft.noop.VARIABLE_VOID_TYPE'
	public static val VARIABLE_INES_HEADER_TYPE = 'org.parisoft.noop.VARIABLE_INES_HEADER_TYPE'
	public static val VARIABLE_DUPLICITY = 'org.parisoft.noop.VARIABLE_DUPLICITY'
	public static val VARIABLE_NEVER_USED = 'org.parisoft.noop.VARIABLE_NEVER_USED'
	public static val VARIABLE_DIMENSION = 'org.parisoft.noop.VARIABLE_DIMENSION'
	public static val PARAMETER_VOID_TYPE = 'org.parisoft.noop.PARAMETER VOID_TYPE'
	public static val PARAMETER_INES_HEADER_TYPE = 'org.parisoft.noop.PARAMETER INES_HEADER_TYPE'
	public static val PARAMETER_STORAGE_TYPE = 'org.parisoft.noop.PARAMETER_STORAGE_TYPE'
	public static val PARAMETER_DUPLICITY = 'org.parisoft.noop.PARAMETER_DUPLICITY'
	public static val PARAMETER_DIMENSION_VALUE = 'org.parisoft.noop.PARAMETER_DIMENSION_VALUE'
	public static val PARAMETER_DIMENSION_CONSISTENCE = 'org.parisoft.noop.PARAMETER_DIMENSION_CONSISTENCE'
	public static val PARAMETER_OVERRIDDEN_DIMENSION = 'org.parisoft.noop.PARAMETER_OVERRIDDEN_DIMENSION'
	public static val METHOD_DUPLICITY = 'org.parisoft.noop.METHOD_DUPLICITY'
	public static val METHOD_DIMENSIONAL_VOID = 'org.parisoft.noop.METHOD DIMENSIONAL_VOID'
	public static val METHOD_STORAGE_TYPE = 'org.parisoft.noop.METHOD_STORAGE_TYPE'
	public static val METHOD_OVERRIDDEN_TYPE = 'org.parisoft.noop.METHOD_OVERRIDDEN_TYPE'
	public static val METHOD_OVERRIDDEN_DIMENSION = 'org.parisoft.noop.METHOD_OVERRIDDEN_DIMENSION'
	public static val RETURN_UNBOUNDED_DIMENSION = 'org.parisoft.noop.RETURN_UNBOUNDED_DIMENSION'
	public static val RETURN_INCONSISTENT_DIMENSION = 'org.parisoft.noop.RETURN_INCONSISTENT_DIMENSION'
	public static val STATEMENT_UNREACHABLE = 'org.parisoft.noop.STATEMENT_UNREACHABLE'
	public static val IF_CONDITION_TYPE = 'org.parisoft.noop.IF_CONDITION_TYPE'
	public static val IF_CONSTANT_CONDITION = 'org.parisoft.noop.IF_CONSTANT_CONDITION'
	public static val IF_EMPTY_BODY = 'org.parisoft.noop.IF_EMPTY_BODY'
	public static val ELSE_EMPTY_BODY = 'org.parisoft.noop.ELSE_EMPTY_BODY'
	public static val FOR_CONSTANT_CONDITION = 'org.parisoft.noop.FOR_CONSTANT_CONDITION'
	public static val BREAK_CONTAINER = 'org.parisoft.noop.BREAK_CONTAINER'
	public static val CONTINUE_CONTAINER = 'org.parisoft.noop.CONTINUE_CONTAINER'
	public static val ASM_REFERENCE = 'org.parisoft.noop.ASM_REFERENCE'
	public static val EXPRESSION_SIDE_EFFECT = 'org.parisoft.noop.EXPRESSION_SIDE_EFFECT'
	public static val ASSIGN_LEFT_SIDE = 'org.parisoft.noop.ASSIGN_LEFT_SIDE'
	public static val ASSIGN_TO_CONSTANT_OR_ROM = 'org.parisoft.noop.ASSIGN_TO_CONSTANT_OR_ROM'
	public static val ASSIGN_VALUE_TYPE = 'org.parisoft.noop.ASSIGN_VALUE_TYPE'
	public static val ASSIGN_VALUE_DIMENSION = 'org.parisoft.noop.ASSIGN_VALUE_DIMENSION'
	public static val ASSIGN_TYPE = 'org.parisoft.noop.ASSIGN_TYPE'

	@Check(NORMAL)
	def classPrepare(NoopClass c) {
		// TODO migrate prepare from generator
	}

	@Check
	def classRecursiveHierarchy(NoopClass c) {
		if (c.superClass == c || c.superClasses.drop(1).exists[isInstanceOf(c)]) {
			error('Recursive hierarchy is not allowed', NOOP_CLASS__SUPER_CLASS, CLASS_RECURSIVE_HIERARCHY,
				c.superClass.name)
		}
	}

	@Check
	def classSuperType(NoopClass c) {
		if (c.superClass?.isVoid) {
			error('''«TypeSystem::LIB_VOID» cannot be extended''', NOOP_CLASS__SUPER_CLASS, CLASS_SUPERCLASS_TYPE)
		}
	}

	@Check
	def fieldTypeSameHierarchy(Variable v) {
		if (v.isField && v.isNonStatic) {
			val varClass = v.containerClass
			val varType = v.typeOf

			if (varClass.isInstanceOf(varType) || varType.isInstanceOf(varClass)) {
				error('Type of non-static fields cannot be on the same hierarchy of the field\'s class',
					VARIABLE__VALUE, FIELD_TYPE_SAME_HIERARCHY)
			}
		}
	}

	@Check
	def fieldStorage(Variable v) {
		if (v.isField && v.isNonStatic && v.storage !== null) {
			error('Non-static fields cannot be tagged', MEMBER__STORAGE, FIELD_STORAGE)
		}
	}

	@Check
	def fieldDuplicity(Variable v) {
		if (v.isField) {
			val duplicates = v.containerClass.declaredFields.takeWhile[it != v].filter[it.name == v.name].toList

			if (duplicates.isNotEmpty) {
				duplicates += v
				duplicates.forEach [
					error('''Field «v.name» is duplicated''', it, MEMBER__NAME, FIELD_DUPLICITY)
				]
			}
		}
	}

	@Check
	def fieldUndeclaredValue(Variable v) {
		if (v.isField && v.isNonStatic) {
			val value = v.value
			val member = if (value instanceof MemberSelect) {
					value.member
				} else if (value instanceof MemberRef) {
					value.member
				} else {
					value.getAllContentsOfType(MemberSelect).map[member].findFirst[isNonStatic] ?:
						value.getAllContentsOfType(MemberRef).map[member].findFirst[isNonStatic]
				}

			if (member !== null && member.isField && member.isNonStatic) {
				if (!v.containerClass.allFieldsTopDown.takeWhile[it != v].exists[it == member]) {
					error('''Field «v.name» cannot reference the field «member.name» before it is declared''',
						VARIABLE__VALUE, FIELD_UNDECLARED_VALUE)
				}
			}
		}
	}

	@Check
	def fieldOverriddenType(Variable v) {
		if (v.isField) {
			val overridden = v.containerClass.allFieldsTopDown.findFirst[v.isOverrideOf(it)]

			if (overridden !== null) {
				val overriddenType = overridden.typeOf

				if (v.typeOf.isNotEquals(overriddenType)) {
					error('''Field «v.name» must have the same «overriddenType.name» type of the overridden field''',
						VARIABLE__VALUE, FIELD_OVERRIDDEN_TYPE)
				}
			}
		}
	}

	@Check
	def fieldOverriddenDimension(Variable v) {
		if (v.isField) {
			val overridden = v.containerClass.superClass.allFieldsTopDown.findFirst[v.isOverrideOf(it)]

			if (overridden !== null) {
				val overrideDimension = overridden.dimensionOf

				if (v.dimensionOf !== overrideDimension) {
					if (overrideDimension.isEmpty) {
						error('''Field «v.name» must have no dimension as the overridden field''', MEMBER__NAME,
							FIELD_OVERRIDDEN_DIMENSION)
					} else if (overrideDimension.size == 1) {
						error('''Field «v.name» must have the same dimension of length «overrideDimension.head» as the overridden field''',
							MEMBER__NAME, FIELD_OVERRIDDEN_DIMENSION)
					} else {
						error('''Field «v.name» must have the same «overrideDimension.join('x')» dimension of the overridden field''',
							MEMBER__NAME, FIELD_OVERRIDDEN_DIMENSION)
					}
				}
			}
		}
	}

	@Check
	def staticFieldContainer(Variable v) {
		if (v.isStatic && v.isNonField) {
			error('''«IF v.isParameter»Parameters«ELSE»Local variables«ENDIF» cannot be declared as static''',
				MEMBER__NAME, STATIC_FIELD_CONTAINER)
		}
	}

	@Check
	def staticFieldStorageType(Variable v) {
		if (v.isStatic && v.storage?.type == StorageType::INLINE) {
			error('''Fields cannot be tagged as «v.storage.type.literal.substring(1)»''', MEMBER__STORAGE,
				STATIC_FIELD_STORAGE_TYPE)
		}
	}

	@Check
	def staticFieldRomType(Variable v) {
		if (v.isStatic && v.isROM && v.typeOf.isNonPrimitive) {
			error('''Type of static fields tagged as «v.storage.type.literal.substring(1)» must be «TypeSystem::LIB_PRIMITIVES.join(', ')»''',
				VARIABLE__VALUE, STATIC_FIELD_ROM_TYPE)
		}
	}

	@Check
	def staticFieldRomValue(Variable v) {
		if (v.isStatic && v.isROM && v.dimensionOf.isEmpty && v.value.isNonConstant) {
			error('''Fields tagged as «v.storage.type.literal.substring(0)» must be declared with a constant value''',
				VARIABLE__VALUE, STATIC_FIELD_ROM_VALUE)
		}
	}

	@Check
	def staticFieldNonStaticValue(Variable v) {
		if (v.isStatic) {
			val value = v.value
			val member = if (value instanceof MemberSelect) {
					value.member
				} else if (value instanceof MemberRef) {
					value.member
				} else {
					value.getAllContentsOfType(MemberSelect).map[member].findFirst[isNonStatic] ?:
						value.getAllContentsOfType(MemberRef).map[member].findFirst[isNonStatic]
				}

			if (member?.isNonStatic) {
				error('''Static field «v.name» cannot reference the non-static «IF member.isField»field«ELSE»method«ENDIF» «member.name»''',
					VARIABLE__VALUE, STATIC_FIELD_NON_STATIC_VALUE)
			}
		}
	}

	@Check
	def staticUndeclaredValue(Variable v) {
		if (v.isStatic) {
			val value = v.value
			val member = if (value instanceof MemberSelect) {
					value.member
				} else if (value instanceof MemberRef) {
					value.member
				} else {
					value.getAllContentsOfType(MemberSelect).map[member].findFirst[isStatic] ?:
						value.getAllContentsOfType(MemberRef).map[member].findFirst[isStatic]
				}

			if (member !== null && member.isStatic && member.containerClass.isEquals(v.containerClass)) {
				if (!v.containerClass.allFieldsTopDown.takeWhile[it != v].exists[it == member]) {
					error('''Field «v.name» cannot reference the field «member.name» before it is declared''',
						VARIABLE__VALUE, FIELD_UNDECLARED_VALUE)
				}
			}
		}
	}

	@Check
	def constantFieldType(Variable v) {
		if (v.isConstant && v.typeOf.isNonPrimitive) {
			error('''Type of constant fields must be «TypeSystem::LIB_PRIMITIVES.join(', ')»''', VARIABLE__VALUE,
				CONSTANT_FIELD_TYPE)
		}
	}

	@Check
	def constantFieldDimension(Variable v) {
		if (v.isConstant && v.dimensionOf.isNotEmpty) {
			error('Constant fields must be non-dimensional', VARIABLE__DIMENSION, CONSTANT_FIELD_DIMENSION)
		}
	}

	@Check
	def constantFieldStorage(Variable v) {
		if (v.isConstant && v.storage !== null) {
			error('Constant fields cannot be tagged', MEMBER__STORAGE, CONSTANT_FIELD_STORAGE)
		}
	}

	@Check
	def constantFieldValue(Variable v) {
		if (v.isConstant && v.value.isNonConstant) {
			error('Constant fields must be declared with a constant value', VARIABLE__VALUE, CONSTANT_FIELD_VALUE)
		}
	}

	@Check
	def variableVoidType(Variable v) {
		if (v.isNonParameter && v.typeOf.isVoid) {
			error('''«TypeSystem::LIB_VOID» is not a valid type for «IF v.isField»fields«ELSE»variables«ENDIF»''',
				VARIABLE__VALUE, VARIABLE_VOID_TYPE)
		}
	}

	@Check
	def variableINesHeaderType(Variable v) {
		if (v.isNonParameter && v.isNonStatic && v.typeOf.isINESHeader) {
			error('''«TypeSystem::LIB_NES_HEADER» is not a valid type for «IF v.isField»non-static fields«ELSE»variables«ENDIF»''',
				VARIABLE__VALUE, VARIABLE_INES_HEADER_TYPE)
		}
	}

	@Check
	def variableDuplicity(Variable v) {
		if (v.isNonField && v.isNonParameter) {
			val duplicates = v.searchDuplicatesOn(v.eContainer).toList

			if (duplicates.isNotEmpty) {
				duplicates += v
				duplicates.forEach [
					error('''Variable «name» is duplicated''', it, MEMBER__NAME, VARIABLE_DUPLICITY)
				]
			}
		}
	}

	@Check
	def variableNeverUsed(Variable v) {
		if (v.isNonField && v.isNonParameter) {
			if (v.getContainerOfType(Method).getAllContentsOfType(MemberSelect).forall[member != v] &&
				v.getContainerOfType(Method).getAllContentsOfType(MemberRef).forall[member != v]) {
				warning('''Variable «v.name» is never used locally''', MEMBER__NAME, VARIABLE_NEVER_USED)
			}
		}
	}

	@Check
	def variableDimension(Variable v) {
		if (v?.value.isUnbounded) {
			error('''«IF v.isField»Fields«ELSE»Variables«ENDIF» cannot be declared with an unbounded array''',
				VARIABLE__VALUE, VARIABLE_DIMENSION)
		}
	}

	@Check
	def parameterVoidType(Variable v) {
		if (v.isParameter && v.type.isVoid) {
			error('''«TypeSystem::LIB_VOID» is not a valid type for parameters''', VARIABLE__TYPE, PARAMETER_VOID_TYPE)
		}
	}

	@Check
	def parameterINesHeaderType(Variable v) {
		if (v.isParameter && v.type.isINESHeader) {
			error('''«TypeSystem::LIB_NES_HEADER» is not a valid type for parameters''', VARIABLE__TYPE,
				PARAMETER_INES_HEADER_TYPE)
		}
	}

	@Check
	def parameterStorageType(Variable v) {
		if (v.isParameter && v.storage?.type != StorageType::ZP) {
			error('''Parameters cannot be tagged as «v.storage.type.literal.substring(1)»''', MEMBER__STORAGE,
				PARAMETER_STORAGE_TYPE)
		}
	}

	@Check
	def parameterDuplicity(Variable v) {
		if (v.isParameter) {
			val duplicates = v.getContainerOfType(Method).params.takeWhile[it != v].filter[it.name == v.name].toList

			if (duplicates.isNotEmpty) {
				duplicates += v
				duplicates.forEach [
					error('''Parameter «name» is duplicated''', it, MEMBER__NAME, PARAMETER_DUPLICITY)
				]
			}
		}
	}

	@Check
	def parameterDimensionValue(Variable v) {
		if (v.isParameter) {
			v.dimension.filter[value?.isNonConstant].forEach [
				error('Length must be a constant expression', it, null, PARAMETER_DIMENSION_VALUE)
			]
		}
	}

	@Check
	def parameterDimensionConsistence(Variable v) {
		if (v.isParameter) {
			if (!(v.dimension.forall[value === null] || v.dimension.forall[value !== null])) {
				v.dimension.filter[value === null].forEach [
					error('''Length expression is missing''', it, null, PARAMETER_DIMENSION_CONSISTENCE)
				]
			}
		}
	}

	@Check
	def parameterOverriddenDimension(Variable v) {
		val m = v.eContainer

		if (m instanceof Method) {
			val overriddenMethod = m.containerClass.allMethodsTopDown.findFirst[m.isOverrideOf(it)]

			if (overriddenMethod !== null) {
				val overridden = overriddenMethod.params.get(m.params.indexOf(v))

				for (i : 0 ..< v.dimension.size) {
					val paramLen = v.dimension.get(i).value
					val overriddenLen = overridden.dimension.get(i).value

					if (paramLen === null && overriddenLen !== null) {
						error('''Lenght must be «overriddenLen.valueOf» as the overridden parameter''',
							v.dimension.get(i), null, PARAMETER_OVERRIDDEN_DIMENSION)
					} else if (paramLen !== null && overriddenLen === null) {
						error('Length must be omitted as the overridden parameter', paramLen, null,
							PARAMETER_OVERRIDDEN_DIMENSION)
					} else if (paramLen !== null && paramLen.isConstant && overriddenLen.isConstant &&
						paramLen.valueOf != overriddenLen.valueOf) {
						error('''Lenght must be «overriddenLen.valueOf» as the overridden parameter''', paramLen, null,
							PARAMETER_OVERRIDDEN_DIMENSION)
					}
				}
			}
		}
	}

	@Check
	def methodDuplicity(Method m) {
		val duplicates = m.containerClass.declaredMethods.takeWhile[it != m].filter [
			it.name == m.name
		].filter [
			it.params.size == m.params.size
		].filter [
			for (i : 0 ..< params.size) {
				val p1 = it.params.get(i)
				val p2 = m.params.get(i)

				if (p1.type.isNotEquals(p2.type)) {
					return false
				}

				if (p1.dimensionOf.size != p2.dimensionOf.size) {
					return false
				}
			}

			true
		].toList

		if (duplicates.isNotEmpty) {
			duplicates += m
			duplicates.forEach [
				error('''Method «name» is duplicated''', it, MEMBER__NAME, METHOD_DUPLICITY)
			]
		}
	}

	@Check
	def methodDimensionalVoid(Method m) {
		if (m.typeOf.isVoid && m.dimensionOf.isNotEmpty) {
			error('''«TypeSystem::LIB_VOID» methods must return a non-dimensional value''', MEMBER__NAME,
				METHOD_DIMENSIONAL_VOID)
		}
	}

	@Check
	def methodStorageType(Method m) {
		if (m.storage?.type != StorageType::PRGROM && m.storage?.type != StorageType::INLINE) {
			error('''Methods cannot be tagged as «m.storage.type.literal.substring(0)»''', MEMBER__STORAGE,
				METHOD_STORAGE_TYPE)
		}
	}

	@Check
	def methodOverriddenType(Method m) {
		val overridden = m.containerClass.allMethodsTopDown.findFirst[m.isOverrideOf(it)]

		if (overridden !== null && m.typeOf.isNonSubclassOf(overridden.typeOf)) {
			error('''Method «m.name» must return the same «overridden.typeOf.name» type or a subtype returned by the overridden method''',
				MEMBER__NAME, METHOD_OVERRIDDEN_TYPE)
		}
	}

	@Check
	def methodOverriddenDimension(Method m) {
		val overridden = m.containerClass.allMethodsTopDown.findFirst[m.isOverrideOf(it)]

		if (overridden !== null) {
			val methodDimension = m.dimensionOf
			val overriddenDimension = overridden.dimensionOf

			if (methodDimension != overriddenDimension) {
				if (overriddenDimension.isEmpty) {
					error('''Method «m.name» must return a non-dimensional value as the overridden method''',
						MEMBER__NAME, METHOD_OVERRIDDEN_DIMENSION)
				} else if (overriddenDimension.size == 1) {
					error('''Method «m.name» must return the same dimension of length «overriddenDimension.head» as returned by the overridden method''',
						MEMBER__NAME, METHOD_OVERRIDDEN_DIMENSION)
				} else {
					error('''Method «m.name» must return the same «overriddenDimension.join('x')» dimension returned by the overridden method''',
						MEMBER__NAME, METHOD_OVERRIDDEN_DIMENSION)
				}
			}
		}
	}

	@Check
	def returnUnboundedDimension(ReturnStatement ret) {
		if (ret.value?.isUnbounded) {
			error('Methods must return bounded dimensional values', RETURN_STATEMENT__VALUE, RETURN_UNBOUNDED_DIMENSION)
		}
	}

	@Check
	def returnInconsistentDimension(ReturnStatement ret) {
		val inconsistents = ret.getContainerOfType(Method).getAllContentsOfType(ReturnStatement).takeWhile [
			it != ret
		].filter [
			it?.value.dimensionOf != ret?.value.dimensionOf
		].toList

		if (inconsistents.isNotEmpty) {
			inconsistents += ret
			inconsistents.forEach [
				error('All returned values in a method must have the same dimension', it, RETURN_STATEMENT__VALUE,
					RETURN_INCONSISTENT_DIMENSION)
			]
		}
	}

	@Check
	def statementUnreachable(Statement statement) {
		val block = statement.eContainer

		if (block instanceof Block) {
			if (block.statements.takeWhile[it != statement].exists[blocker]) {
				warning('Dead code', statement, null, STATEMENT_UNREACHABLE)
			}
		}
	}

	@Check
	def ifConditionType(IfStatement ifStatement) {
		if (ifStatement.condition.typeOf.isNonBoolean) {
			error('''Ifs condition must be a «TypeSystem::LIB_BOOL» expression''', IF_STATEMENT__CONDITION,
				IF_CONDITION_TYPE)
		}
	}

	@Check
	def ifConstantCondition(IfStatement ifStatement) {
		if (ifStatement.condition.isConstant) {
			val condition = ifStatement.condition.valueOf

			if (condition instanceof Boolean) {
				warning('''If's condition always evaluate to «ifStatement.condition.valueOf»''',
					IF_STATEMENT__CONDITION, IF_CONSTANT_CONDITION)

				if (condition) {
					var nextElse = ifStatement.^else

					while (nextElse !== null) {
						if (nextElse.body !== null) {
							warning('Dead code', nextElse.body, null, IF_CONSTANT_CONDITION)
						} else if (nextElse.^if !== null) {
							warning('Dead code', nextElse.^if.body, null, IF_CONSTANT_CONDITION)
						}

						nextElse = nextElse.^if?.^else
					}
				} else {
					warning('Dead code', ifStatement.body, null, IF_CONSTANT_CONDITION)
				}
			}
		}
	}

	@Check
	def ifEmptyBody(IfStatement ifStatement) {
		if (ifStatement.body.statements.isEmpty) {
			warning('Useless if statement', IF_STATEMENT__NAME, IF_EMPTY_BODY)
		}
	}

	@Check
	def elseEmptyBody(ElseStatement elseStatement) {
		if (elseStatement.body?.statements?.isEmpty) {
			warning('Useless else statement', ELSE_STATEMENT__NAME, ELSE_EMPTY_BODY)
		}
	}

	@Check
	def forConstantCondition(ForStatement forStatement) {
		if (forStatement.condition?.isConstant) {
			val condition = forStatement.condition.valueOf

			if (condition instanceof Boolean && (condition as Boolean) == false) {
				warning('For\'s condition always evaluate to false', FOR_STATEMENT__CONDITION, FOR_CONSTANT_CONDITION)
				warning('Dead code', forStatement.body, null, FOR_CONSTANT_CONDITION)
			}
		}
	}

	@Check
	def breakContainer(BreakStatement break) {
		if (break.getContainerOfType(ForStatement) === null && break.getContainerOfType(ForeverStatement) === null) {
			error('Break statement must be inside a loop statement', BREAK_STATEMENT__NAME, BREAK_CONTAINER)
		}
	}

	@Check
	def continueContainer(ContinueStatement continue) {
		if (continue.getContainerOfType(ForStatement) === null &&
			continue.getContainerOfType(ForeverStatement) === null) {
			error('Continue statement must be inside a loop statement', CONTINUE_STATEMENT__NAME, CONTINUE_CONTAINER)
		}
	}

	@Check
	def asmReference(AsmStatement asm) {
		asm.vars.reject[it instanceof MemberSelect || it instanceof MemberRef || isThisOrSuper].forEach [
			error('Expected a variable, field or method reference', it, null, ASM_REFERENCE)
		]
	}

	@Check
	def expressionSideEffect(Expression expr) {
		if (expr.eContainer instanceof Block) {
			val invalid = switch (expr) {
				AssignmentExpression: false
				DecExpression: false
				IncExpression: false
				MemberSelect: expr.member instanceof Variable
				MemberRef: expr.member instanceof Variable
				default: true
			}

			if (invalid) {
				error('This expression is not allowed here, since it doesn\'t cause any side effects', expr, null,
					EXPRESSION_SIDE_EFFECT)
			}
		}
	}

	@Check
	def assignLeftSide(AssignmentExpression assignment) {
		val left = assignment.left
		val member = switch (left) {
			MemberSelect: left.member
			MemberRef: left.member
		}

		if (member === null || member instanceof Method) {
			error('Can only assign a value to a variable', ASSIGNMENT_EXPRESSION__LEFT, ASSIGN_LEFT_SIDE)
		}
	}

	@Check
	def assignToConstantOrRom(AssignmentExpression assignment) {
		val left = assignment.left
		val member = switch (left) {
			MemberSelect: left.member
			MemberRef: left.member
		}

		if (member instanceof Variable) {
			if (member.isConstant) {
				error('Cannot assign a value to a constant field', ASSIGNMENT_EXPRESSION__LEFT,
					ASSIGN_TO_CONSTANT_OR_ROM)
			} else if (member.isStatic && member.isROM) {
				error('''Cannot assign a value to a field tagged as «member.storage.type.literal.substring(1)»''',
					ASSIGNMENT_EXPRESSION__LEFT, ASSIGN_TO_CONSTANT_OR_ROM)
			}
		}
	}

	@Check
	def assignValueDimension(AssignmentExpression assignment) {
		val leftDim = assignment.left.dimensionOf
		val rightDim = assignment.right.dimensionOf

		if (leftDim.size != rightDim.size) {
			error('''Cannot assign a value to a variable with incompatible dimensions''', ASSIGNMENT_EXPRESSION__RIGHT,
				ASSIGN_VALUE_DIMENSION)
		}
	}

	@Check
	def assignType(AssignmentExpression assignment) {
		val type = assignment.assignment
		val leftType = assignment.left.typeOf
		val rightType = assignment.right.typeOf

		if (type == ADD_ASSIGN || type == SUB_ASSIGN || type == MUL_ASSIGN || type == DIV_ASSIGN ||
			type == MOD_ASSIGN || type == BLS_ASSIGN || type == BRS_ASSIGN) {
			if (leftType.isNonNumeric) {
				error('''Invalid assignment to a non-numeric variable of type «leftType.name»''',
					ASSIGNMENT_EXPRESSION__ASSIGNMENT, ASSIGN_TYPE)
			} else if (rightType.isNonNumeric) {
				error('''Right hand side of assignment must be a numberic value''', ASSIGNMENT_EXPRESSION__RIGHT,
					ASSIGN_VALUE_TYPE)
			}
		} else if (type == BAN_ASSIGN || type == BOR_ASSIGN) {
			if (leftType.isNonNumeric && leftType.isNonBoolean) {
				error('''Invalid assignment to a non-numeric non-boolean variable of type «assignment.left.typeOf.name»''',
					ASSIGNMENT_EXPRESSION__ASSIGNMENT, ASSIGN_TYPE)
			} else if (rightType.isNonNumeric && rightType.isNonBoolean) {
				error('''Right hand side of assignment must be a numberic or boolean value''',
					ASSIGNMENT_EXPRESSION__RIGHT, ASSIGN_VALUE_TYPE)

			}
		} else if (type == ASSIGN) {
			if (rightType.isNonInstanceOf(leftType)) {
				error('''Cannot assign a value of type «rightType.name» value to a variable of type «leftType.name»''',
					ASSIGNMENT_EXPRESSION__RIGHT, ASSIGN_VALUE_TYPE)
			}
		}

	}

	private def Iterable<Variable> searchDuplicatesOn(Variable v, EObject container) {
		if (container === null) {
			return newArrayList
		}

		return switch (container) {
			Block:
				container.statements.takeWhile [
					it != v && !it.getAllContentsOfType(Variable).contains(v)
				].filter(Variable).filter[it.name == v.name]
			ForStatement:
				container.variables.takeWhile[it != v].filter(Variable).filter[it.name == v.name]
			Method:
				container.params.filter[it.name == v.name]
			default:
				newArrayList
		} + v.searchDuplicatesOn(container.eContainer)
	}

	private def isBlocker(Statement s) {
		s.isBreakContinueOrReturn || s.isInfiniteLoop || s.containsBlocker
	}

	private def isInfiniteLoop(Statement s) {
		switch (s) {
			ForStatement: {
				if (s.condition === null || s.condition.isConstant) {
					val condition = s.condition?.valueOf ?: true

					if (condition instanceof Boolean && (condition as Boolean)) {
						return s.body.getAllContentsOfType(Statement).forall[!isBreakOrReturn]
					}
				} else {
					false
				}
			}
			ForeverStatement:
				s.body.getAllContentsOfType(Statement).forall[!isBreakOrReturn]
			default:
				false
		}
	}

	private def Boolean containsBlocker(EObject s) {
		if (s === null) {
			return false
		}

		switch (s) {
			IfStatement: {
				if (s.condition.isConstant) {
					val condition = s.condition.valueOf

					if (condition instanceof Boolean) {
						if (condition) {
							s.body.statements.exists[blocker]
						} else {
							s.^else.containsBlocker
						}
					} else {
						false
					}
				} else {
					s.body.statements.exists[blocker] && s.^else.containsBlocker
				}
			}
			ElseStatement:
				if (s.body !== null) {
					s.body.statements.exists[blocker]
				} else {
					s.^if.containsBlocker
				}
			default:
				false
		}

	}

	private def isBreakContinueOrReturn(Statement s) {
		s instanceof ReturnStatement || s instanceof BreakStatement || s instanceof ContinueStatement
	}

	private def isBreakOrReturn(Statement s) {
		s instanceof ReturnStatement || s instanceof BreakStatement
	}

}
