grammar org.parisoft.noop.Noop hidden(WS, ML_COMMENT, SL_COMMENT) // with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate noop "http://www.parisoft.org/noop/Noop"

NoopClass:
	name=CID ('extends' superClass=[NoopClass|CID])? '{' LF*
	members+=Member*
	'}';

Member:
	(Variable | Method) LF+;

Storage:
	type=StorageType ('[' bank=Expression ']')?;

Variable:
	name=ID storage=Storage? ':' value=Expression;

Parameter returns Variable:
	type=[NoopClass|CID] (dimension+='[' ']')* name=ID;

Method:
	name=ID '(' (params+=Parameter (',' params+=Parameter)*)? ')' storage=Storage? body=Block;

Block:
	{Block} '{' LF* statements+=Statement* '}';

Statement:
	(Variable |
	ReturnStatement |
	Expression |
	IfStatement |
	ForStatement |
	ForeverStatement |
	AsmStatement) LF+;

ReturnStatement:
	ReturnValueStatement |
	{ReturnStatement} name='return';

ReturnValueStatement returns ReturnStatement:
	name='return' value=Expression;

IfStatement:
	name='if' '(' condition=Expression ')' body=Block else=ElseStatement?;

ElseStatement:
	name='else' (body=Block | if=IfStatement);

ForStatement:
	name='for' '(' ((variables+=Variable | assignments+=AssignmentExpression) (',' (variables+=Variable |
	assignments+=AssignmentExpression))*)?
	';' condition=Expression?
	';' (expressions+=Expression (',' expressions+=Expression)*)? ')'
	body=Block;

ForeverStatement:
	name='forever' body=Block;

AsmStatement:
	codes+=ASM_TO_ASM | (codes+=ASM_TO_VAR vars+=[Variable] (codes+=VAR_TO_VAR vars+=[Variable])* codes+=VAR_TO_ASM);

terminal ASM_TO_VAR:
	'!' !('!' | '?')* '?';

terminal VAR_TO_VAR:
	'?' !('!' | '?')* '?';

terminal VAR_TO_ASM:
	'?' !('!' | '?')* '!';

terminal ASM_TO_ASM:
	'!' !('!' | '?')* '!';

Expression:
	AssignmentExpression;

AssignmentExpression returns Expression:
	OrExpression ({AssignmentExpression.left=current} assignment=AssignmentType right=Expression)?;

OrExpression returns Expression:
	AndExpression ({OrExpression.left=current} 'or' right=AndExpression)*;

AndExpression returns Expression:
	EqualityExpression ({AndExpression.left=current} 'and' right=EqualityExpression)*;

EqualityExpression returns Expression:
	ComparisonExpression (({EqualsExpression.left=current} '=' | {DifferExpression.left=current} '#')
	right=ComparisonExpression)*;

ComparisonExpression returns Expression:
	AddOrSubExpression
	(({GtExpression.left=current} '>' |
	{GeExpression.left=current} '>=' |
	{LtExpression.left=current} '<' |
	{LeExpression.left=current} '<=')
	right=AddOrSubExpression)*;

AddOrSubExpression returns Expression:
	MulOrDivExpression (({AddExpression.left=current} '+' | {SubExpression.left=current} '-')
	right=MulOrDivExpression)*;

MulOrDivExpression returns Expression:
	BitwiseExpression (({MulExpression.left=current} '*' | {DivExpression.left=current} '/')
	right=BitwiseExpression)*;

BitwiseExpression returns Expression:
	EorExpression
	(({BOrExpression.left=current} '|' |
	{BAndExpression.left=current} '&' |
	{LShiftExpression.left=current} '<<' |
	{RShiftExpression.left=current} '>>')
	right=EorExpression)*;

EorExpression returns Expression:
	NotExpression | {EorExpression} '~' right=EorExpression;

NotExpression returns Expression:
	SigNegExpression | {NotExpression} 'not' right=NotExpression;

SigNegExpression returns Expression:
	SigPosExpression | {SigNegExpression} '-' right=SigNegExpression;

SigPosExpression returns Expression:
	DecExpression | {SigPosExpression} '+' right=SigPosExpression;

DecExpression returns Expression:
	IncExpression | {DecExpression} '--' right=DecExpression;

IncExpression returns Expression:
	SelectionExpression | {IncExpression} '++' right=IncExpression;

SelectionExpression returns Expression:
	TerminalExpression ({MemberSelection.receiver=current} '.'
	((member=[Member] ('(' (args+=Expression (',' args+=Expression)*)? ')')?) indexes+=Index* |
	((instanceOf?='instanceOf' | cast?='as') '(' type=[NoopClass|CID] ')')))*;

TerminalExpression returns Expression:
	{ByteLiteral} value=Byte |
	{BoolLiteral} value=BOOL |
	{StringLiteral} value=STRING |
	{ArrayLiteral} '[' LF* (values+=Expression (',' LF* values+=Expression)* LF*)? ']' |
	{This} 'this' |
	{Super} 'super' |
	{NewInstance} type=[NoopClass|CID] (constructor=Constructor | dimension+=Index+)? |
	{MemberRef} member=[Member] ('(' (args+=Expression (',' args+=Expression)*)? ')')?
	indexes+=Index* |
	'(' Expression ')';

Constructor:
	{Constructor} '{' LF* (field+=ConstructorField (',' LF* field+=ConstructorField)* LF*)? '}';

ConstructorField:
	name=[Variable] ':' value=Expression;

Index:
	'[' value=Expression ']';

enum AssignmentType:
	ASSIGN=':=' | ADD_ASSIGN='+=' | SUB_ASSIGN='-=' | MUL_ASSIGN='*=' | DIV_ASSIGN='/=';

enum StorageType:
	PRGROM='@PRG-ROM' | CHRROM='@CHR-ROM';

Byte returns ecore::EIntegerObject:
	HEX | BIN | CHA | INT;

terminal CHA returns ecore::EChar:
	"'" (('\\' .) | !('\\' | "'")) "'";

terminal HEX returns ecore::EInt:
	'$' ('0'..'9' | 'A'..'F')+;

terminal BIN returns ecore::EInt:
	'%' ('0' | '1')+;

terminal BOOL returns ecore::EBoolean:
	'true' | 'false';

terminal ID:
	('a'..'z' | '_' | '#') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal CID:
	('A'..'Z') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal INT returns ecore::EInt:
	('0'..'9')+;

terminal LF:
	'\r'? '\n';

terminal STRING:
	'"' ('\\' . | !('\\' | '"'))* '"';

terminal ML_COMMENT:
	'/*'->('*/' ('\r'? '\n')*);

terminal SL_COMMENT:
	'//' !('\n' | '\r')*;

terminal WS:
	(' ' | '\t')+;
