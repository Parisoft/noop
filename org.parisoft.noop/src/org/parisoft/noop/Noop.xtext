grammar org.parisoft.noop.Noop hidden(WS, ML_COMMENT, SL_COMMENT) // with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate noop "http://www.parisoft.org/noop/Noop"

NoopClass:
	name=CID ('extends' superClass=[NoopClass|CID])? '{' LF*
	members+=Member*
	'}' LF?;

Member:
	(Variable | Method) LF+;

Storage:
	type=StorageType ('[' location=Expression ']')?;

Variable:
	name=ID storage=Storage? ':' value=Expression;

Parameter returns Variable:
	type=[NoopClass|CID] (dimension+='[' ']')* name=ID storage=Storage?;

Method:
	name=ID '(' (params+=Parameter (',' params+=Parameter)*)? ')' (dimension+='[' ']')* storage=Storage? body=Block;

Block:
	{Block} '{' LF* statements+=Statement* '}';

Statement:
	(Variable |
	ReturnStatement |
	Expression |
	IfStatement |
	ForStatement |
	ForeverStatement |
	ContinueStatement |
	BreakStatement |
	AsmStatement) LF+;

ReturnStatement:
	name='return' (value=Expression)?;

IfStatement:
	name='if' '(' condition=Expression ')' body=Block else=ElseStatement?;

ElseStatement:
	name='else' (body=Block | if=IfStatement);

ForStatement:
	name='for' '(' ((variables+=Variable | assignments+=AssignmentExpression) (',' (variables+=Variable |
	assignments+=AssignmentExpression))*)?
	';' condition=Expression?
	';' (expressions+=Expression (',' expressions+=Expression)*)? ')'
	body=Block;

ForeverStatement:
	name='forever' body=Block;

ContinueStatement:
	name='continue';

BreakStatement:
	name='break';

AsmStatement:
	codes+=ASM_TO_ASM | (codes+=ASM_TO_VAR vars+=[Variable] (codes+=VAR_TO_VAR vars+=[Variable])* codes+=VAR_TO_ASM);

Expression:
	AssignmentExpression;

AssignmentExpression returns Expression:
	LogicalExpression ({AssignmentExpression.left=current} assignment=AssignmentType right=Expression)?;

LogicalExpression returns Expression:
	BitwiseExpression (({OrExpression.left=current} 'or' | {AndExpression.left=current} 'and') right=BitwiseExpression)*;

BitwiseExpression returns Expression:
	EqualityExpression (({BOrExpression.left=current} '|' | {BAndExpression.left=current} '&') right=EqualityExpression)*;

EqualityExpression returns Expression:
	RelationalExpression (({EqualsExpression.left=current} '=' | {DifferExpression.left=current} '#')
	right=RelationalExpression)*;

RelationalExpression returns Expression:
	InheritsExpression
	(({GtExpression.left=current} '>' |
	{GeExpression.left=current} '>=' |
	{LtExpression.left=current} '<' |
	{LeExpression.left=current} '<=')
	right=AdditiveExpression)*;

InheritsExpression returns Expression:
	ShiftExpression ({InheritsExpression.left=current} 'inherits' type=[NoopClass|CID])?;

ShiftExpression returns Expression:
	AdditiveExpression (({LShiftExpression.left=current} '<<' | {RShiftExpression.left=current} '>>')
	right=AdditiveExpression)*;

AdditiveExpression returns Expression:
	MultiplicativeExpression (({AddExpression.left=current} '+' | {SubExpression.left=current} '-')
	right=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	UnaryExpression (({MulExpression.left=current} '*' | {DivExpression.left=current} '/')
	right=UnaryExpression)*;

UnaryExpression returns Expression:
	CastExpression |
	(({EorExpression} '~' |
	{NotExpression} 'not' |
	{SigNegExpression} '-' |
	{SigPosExpression} '+' |
	{DecExpression} '--' |
	{IncExpression} '++')
	right=UnaryExpression);

CastExpression returns Expression:
	SelectionExpression ({CastExpression.left=current} 'as' type=[NoopClass|CID])?;

SelectionExpression returns Expression:
	TerminalExpression ({MemberSelect.receiver=current} '.'
	member=[Member] (hasArgs?='(' (args+=Expression (',' args+=Expression)*)? ')')? indexes+=Index*)*;

TerminalExpression returns Expression:
	{ByteLiteral} value=Byte |
	{BoolLiteral} value=BOOL |
	{StringLiteral} value=STRING |
	{ArrayLiteral} '[' LF* (values+=Expression (',' LF* values+=Expression)* LF*)? ']' |
	{This} 'this' |
	{Super} 'super' |
	{NewInstance} type=[NoopClass|CID] (constructor=Constructor | dimension+=Index+)? |
	{MemberRef} member=[Member] (hasArgs?='(' (args+=Expression (',' args+=Expression)*)? ')')?
	indexes+=Index* |
	'(' Expression ')';

Constructor:
	{Constructor} '{' LF* (fields+=ConstructorField (',' LF* fields+=ConstructorField)* LF*)? '}';

ConstructorField:
	variable=[Variable] ':' value=Expression;

Index:
	'[' value=Expression ']';

enum AssignmentType:
	ASSIGN=':=' | ADD_ASSIGN='+=' | SUB_ASSIGN='-=' | MUL_ASSIGN='*=' | DIV_ASSIGN='/=' | BOR_ASSIGN='|=' |
	BAN_ASSIGN='&=' | BLS_ASSIGN='<<=' | BRS_ASSIGN='>>=';

enum StorageType:
	PRGROM='@PRG-ROM' | CHRROM='@CHR-ROM' | RAM='@RAM';

terminal ASM_TO_VAR:
	'!' !('!' | '?')* '?';

terminal VAR_TO_VAR:
	'?' !('!' | '?')* '?';

terminal VAR_TO_ASM:
	'?' !('!' | '?')* '!';

terminal ASM_TO_ASM:
	'!' !('!' | '?')* '!';

Byte returns ecore::EIntegerObject:
	HEX | BIN | CHA | INT;

terminal CHA returns ecore::EChar:
	"'" (('\\' .) | !('\\' | "'")) "'";

terminal HEX returns ecore::EInt:
	'0x' ('0'..'9' | 'A'..'F')+;

terminal BIN returns ecore::EInt:
	'0b' ('0' | '1')+;

terminal BOOL returns ecore::EBoolean:
	'true' | 'false';

terminal ID:
	(('a'..'z') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*) | (('_' | '$') ('$')? ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')+); //  ('a'..'z' | '_' | '$') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
terminal CID:
	('A'..'Z') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal INT returns ecore::EInt:
	('0'..'9')+;

terminal LF:
	'\r'? '\n';

terminal STRING:
	'"' ('\\' . | !('\\' | '"'))* '"';

terminal ML_COMMENT:
	'/*'->('*/' ('\r'? '\n')*);

terminal SL_COMMENT:
	'//' !('\n' | '\r')*;

terminal WS:
	(' ' | '\t')+;
