grammar org.parisoft.noop.Noop hidden(WS, ML_COMMENT, SL_COMMENT) // with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate noop "http://www.parisoft.org/noop/Noop"

NoopClass:
	name=ID ('extends' superClass=[NoopClass])? '{' LF*
	members+=Member*
	'}';

Member:
	(Variable | Method) LF+;

Variable:
	name=ID ':' value=Expression;

Parameter returns Variable:
	type=[NoopClass] name=ID;

Method:
	name=ID '(' (params+=Parameter (',' params+=Parameter)*)? ')' body=Block;

Block:
	{Block} '{' LF* statements+=Statement* '}';

Statement:
	(Variable |
	ReturnStatement |
	Expression |
	IfStatement) LF+;

ReturnStatement:
	=> ReturnValueStatement |
	{ReturnStatement} 'return';

ReturnValueStatement returns ReturnStatement:
	'return' value=Expression;

IfStatement:
	name='if' '(' condition=Expression ')' body=Block else=ElseStatement?;

ElseStatement:
	name='else' (body=Block | if=IfStatement);

Expression:
	AssignmentExpression;

AssignmentExpression returns Expression:
	OrExpression
	({AssignmentExpression.left=current} assignment=AssignmentType right=Expression)?;

OrExpression returns Expression:
	AndExpression ({OrExpression.left=current} 'or' right=AndExpression)*;

AndExpression returns Expression:
	EqualityExpression ({AndExpression.left=current} 'and' right=EqualityExpression)*;

EqualityExpression returns Expression:
	ComparisonExpression (({EqualsExpression.left=current} '=' | {DifferExpression.left=current} '#')
	right=ComparisonExpression)*;

ComparisonExpression returns Expression:
	AddOrSubExpression
	(({GtExpression.left=current} '>' |
	{GeExpression.left=current} '>=' |
	{LtExpression.left=current} '<' |
	{LeExpression.left=current} '<=')
	right=AddOrSubExpression)*;

AddOrSubExpression returns Expression:
	MulOrDivExpression (=> ({AddExpression.left=current} '+' | {SubExpression.left=current} '-')
	right=MulOrDivExpression)*;

MulOrDivExpression returns Expression:
	BitwiseExpression (({MulExpression.left=current} '*' | {DivExpression.left=current} '/')
	right=BitwiseExpression)*;

BitwiseExpression returns Expression:
	EorExpression
	(({BOrExpression.left=current} '|' |
	{BAndExpression.left=current} '&' |
	{LShiftExpression.left=current} '<<' |
	{RShiftExpression.left=current} '>>')
	right=EorExpression)*;

EorExpression returns Expression:
	NotExpression |
	{EorExpression} '~' right=EorExpression;

NotExpression returns Expression:
	SigNegExpression |
	{NotExpression} 'not' right=NotExpression;

SigNegExpression returns Expression:
	SigPosExpression | {SigNegExpression} '-' right=SigNegExpression;

SigPosExpression returns Expression:
	DecExpression | {SigPosExpression} '+' right=SigPosExpression;

DecExpression returns Expression:
	IncExpression | {DecExpression} '--' right=DecExpression;

IncExpression returns Expression:
	SelectionExpression | {IncExpression} '++' right=IncExpression;

SelectionExpression returns Expression:
	TerminalExpression ({MemberSelection.receiver=current} '.'
	((member=[Member] => (methodInvocation?='(' (args+=Expression (',' args+=Expression)*)? ')')?) |
	((instanceOf?='instanceOf' | cast?='as') '(' type=[NoopClass] ')')))*;

TerminalExpression returns Expression:
	{ByteLiteral} value=Byte |
	{BoolLiteral} value=Bool |
	{CharLiteral} value=Char |
	{This} 'this' |
	{Super} 'super' |
	{NewInstance} 'new' type=[NoopClass] ('{' LF* field+=Variable (',' LF* field+=Variable)* LF* '}')? |
	{InjectInstance} 'inject' type=[NoopClass] |
	{MemberRef} member=[Member] => (methodInvacation?='(' (args+=Expression (',' args+=Expression)*)? ')')? |
	'(' Expression ')';

QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildcard:
	QualifiedName '.*'?;

enum AssignmentType:
	ASSIGN=':=' | ADD_ASSIGN='+=' | SUB_ASSIGN='-=' | MUL_ASSIGN='*=' | DIV_ASSIGN='/=';

Byte returns ecore::EIntegerObject:
	HEX | BIN | INT;

Bool returns ecore::EBooleanObject:
	'true' | 'false';

Char returns ecore::ECharacterObject:
	CHA;

terminal CHA returns ecore::EChar:
	'\'' . '\'';

terminal HEX returns ecore::EInt:
	'$' ('0'..'9' | 'A'..'F')+;

terminal BIN returns ecore::EInt:
	'%' ('0' | '1')+;

terminal ID:
	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal INT returns ecore::EInt:
	('0'..'9')+;

terminal LF:
	'\r'? '\n';

terminal STRING:
	'"' ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | '"'))* '"' |
	"'" ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | "'"))* "'";

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')*;

terminal WS:
	(' ' | '\t')+;

terminal ANY_OTHER:
	.;