/*
 * generated by Xtext 2.10.0
 */
package org.parisoft.noop.generator

import com.google.inject.Inject
import java.util.Objects
import java.util.concurrent.atomic.AtomicInteger
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.IResourceDescriptions
import org.parisoft.noop.^extension.Classes
import org.parisoft.noop.^extension.Collections
import org.parisoft.noop.^extension.Datas
import org.parisoft.noop.^extension.Expressions
import org.parisoft.noop.^extension.Files
import org.parisoft.noop.^extension.Members
import org.parisoft.noop.^extension.Statements
import org.parisoft.noop.^extension.TypeSystem
import org.parisoft.noop.noop.NewInstance
import org.parisoft.noop.noop.NoopClass
import org.parisoft.noop.noop.NoopPackage

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class NoopGenerator extends AbstractGenerator {

	@Inject extension Files
	@Inject extension Classes
	@Inject extension Members
	@Inject extension Statements
	@Inject extension Collections
	@Inject extension Expressions
	@Inject extension IQualifiedNameProvider
	@Inject IResourceDescriptions descriptions

	var lastSuccesfullCompile = 0L

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		if (System::currentTimeMillis - lastSuccesfullCompile > 5) {
			val asm = resource.compile

			if (asm !== null) {
				fsa.generateFile(asm.asmFileName, asm.content)

				val asm8 = new Asm8 => [
					inputFileName = fsa.getURI(asm.asmFileName).toFile.absolutePath
					outputFileName = fsa.getURI(asm.binFileName).toFile.absolutePath
					listFileName = fsa.getURI(asm.lstFileName).toFile.absolutePath
				]

				try {
					asm8.compile
				} catch (Exception exception) {
					fsa.deleteFile(asm.binFileName)
					throw exception
				}
			}
		}
		
		lastSuccesfullCompile = System::currentTimeMillis
	}

	private def compile(Resource resource) {
		val gameImpl = resource.gameClass

		if (gameImpl === null) {
			return null
		}

		val ctx = gameImpl.prepare
		gameImpl.alloc(ctx)
		val content = ctx.compile.optimize

		new ASM(gameImpl.name, content)
	}

	private def optimize(CharSequence code) {
		val lines = code.toString.split(System::lineSeparator)
		val builder = new StringBuilder
		val AtomicInteger skip = new AtomicInteger

		lines.forEach [ line, i |
			var next = if(i + 1 < lines.length) lines.get(i + 1) else ''

			if (skip.get > 0) {
				skip.decrementAndGet
			} else if (line == '\tPLA' && next == '\tPHA') {
				skip.set(1)
			} else if ((line.startsWith('\tJMP') || line.startsWith('\tRTS')) &&
				(next.startsWith('\tJMP') || next.startsWith('\tRTS'))) {
				while (next.startsWith('\tJMP') || next.startsWith('\tRTS')) {
					next = lines.get(i + 1 + skip.incrementAndGet)
				}

				builder.append(line).append(System::lineSeparator)
			} else if (line.startsWith('\tJSR') && next.startsWith('\tRTS')) {
				while (next.startsWith('\tRTS')) {
					next = lines.get(i + 1 + skip.incrementAndGet)
				}

				builder.append('''	JMP «line.substring(5)»''').append(System::lineSeparator)
			} else {
				builder.append(line).append(System::lineSeparator)
			}
		]

		builder.toString
	}

	private def gameClass(Resource resource) {
		val resourceProject = resource.URI.projectURI

		val games = descriptions.allResourceDescriptions.map [
			getExportedObjectsByType(NoopPackage::eINSTANCE.noopClass)
		].flatten.map [
			var obj = it.EObjectOrProxy

			if (obj.eIsProxy) {
				obj = resource.resourceSet.getEObject(it.EObjectURI, true)
			}

			obj as NoopClass
		].filter [
			Objects::equals(eResource.URI?.projectURI, resourceProject)
		].filter [
			it.isGame && it.name != TypeSystem::LIB_GAME
		].toSet

		if (games.size > 1) {
			throw new IllegalArgumentException("More than 1 game implementation found: " + games.map[name])
		}

		return games.head
	}

	private def compile(AllocContext ctx) '''
		;----------------------------------------------------------------
		; Class Metadata
		;----------------------------------------------------------------
		«var classCount = 0»
		«val classes = ctx.classes.values.filter[nonPrimitive].sortWith[a, b|
			val aHasConstructor = ctx.constructors.containsKey(a.nameOf)
			val bHasConstructor = ctx.constructors.containsKey(b.nameOf)
			
			if (aHasConstructor && !bHasConstructor) {
				return -1 //don't know why this works inverted ... should be 1 instead
			}
			
			if (!aHasConstructor && bHasConstructor) {
				return 1 //don't know why this works inverted ... should be -1 instead
			}
			
			return a.name.compareTo(b.name)
		]»
		«FOR noopClass : classes»
			«noopClass.nameOf» = «classCount++»
			«val fieldOffset = new AtomicInteger(1)»
			«FOR field : noopClass.allFieldsTopDown.filter[nonStatic]»
				«field.nameOfOffset» = «fieldOffset.getAndAdd(field.sizeOf)»
			«ENDFOR»
			
		«ENDFOR»
		;----------------------------------------------------------------
		; Constant variables
		;----------------------------------------------------------------
		«Members::TRUE» = 1
		«Members::FALSE» = 0
		«Members::FT_DPCM_OFF» = $C000
		«Members::FT_DPCM_PTR» = («Members::FT_DPCM_OFF»&$3fff)>>6
		«FOR cons : ctx.constants.values»
			«cons.nameOfConstant» = «cons.value.compileConstant»
		«ENDFOR»
		
		;----------------------------------------------------------------
		; Static variables
		;----------------------------------------------------------------
		«FOR page : 0..< ctx.counters.size»
			«IF ctx.resetCounter(page) == 0»«noop»«ENDIF»
		«ENDFOR»
		«FOR page : 0..< ctx.counters.size»
			«val staticVars = ctx.statics.values.filter[(storage?.location?.valueOf as Integer ?: Datas::VAR_PAGE) === page]»
			«FOR staticVar : staticVars»
				«staticVar.nameOfStatic» = «ctx.getAndMoveCounter(page, staticVar.sizeOf).toHexString(4)»
			«ENDFOR»
		«ENDFOR»
		
		;----------------------------------------------------------------
		; Local variables
		;----------------------------------------------------------------
		«Members::TEMP_VAR_NAME1» = «ctx.counters.get(Datas::PTR_PAGE).getAndAdd(2).toHexString(4)»
		«Members::TEMP_VAR_NAME2» = «ctx.counters.get(Datas::PTR_PAGE).getAndAdd(2).toHexString(4)»
		«Members::TEMP_VAR_NAME3» = «ctx.counters.get(Datas::PTR_PAGE).getAndAdd(2).toHexString(4)»
		«val chunks = ctx.pointers.values.flatten.sort + ctx.variables.values.flatten.sort»
		«FOR chunk : chunks»
			«val delta = ctx.counters.get(chunk.page).get - chunk.page * 0x0100»
			«chunk.shiftTo(delta)»
		«ENDFOR»
«««		«FOR i : 1 ..< chunks.size»
«««			«val c0 = chunks.get(i - 1)»
«««			«val c1 = chunks.get(i)»
«««			«val delta = c1.deltaFrom(c0)»
«««			«IF c0.ZP == c1.ZP && delta < 0»
«««				«c1.shiftTo(delta)»
«««			«ENDIF»
«««		«ENDFOR»
		«FOR chunk : chunks»
			«chunk.variable» = «chunk.lo.toHexString(4)»
		«ENDFOR»
		
		;----------------------------------------------------------------
		; iNES Header
		;----------------------------------------------------------------
			.db 'NES', $1A ;identification of the iNES header
			.db «(ctx.header.fieldValue('prgRomPages') as Integer).toHexString» ;number of 16KB PRG-ROM pages
			.db «(ctx.header.fieldValue('chrRomPages') as Integer).toHexString» ;number of 8KB CHR-ROM pages
			.db «(ctx.header.fieldValue('mapper') as Integer).toHexString» | «(ctx.header.fieldValue('mirroring') as Integer).toHexString»
			.dsb 9, $00 ;clear the remaining bytes to 16
			
		;----------------------------------------------------------------
		; PRG-ROM Bank(s)
		;----------------------------------------------------------------
			.base $10000 - («(ctx.header.fieldValue('prgRomPages') as Integer).toHexString» * $4000) 
		
		«FOR rom : ctx.prgRoms.values.filter[nonDMC]»
			«rom.compile(new CompileContext)»
		«ENDFOR»
		«IF ctx.methods.values.exists[objectSize] && ctx.constructors.size > 0»
			Object.$sizes:
				.db «ctx.constructors.values.sortBy[type.name].map[type.sizeOf].join(', ', [toHexString])»
		«ENDIF»
		
		;-- Methods -----------------------------------------------------
		«FOR method : ctx.methods.values.sortBy[fullyQualifiedName]»
			«method.compile(new CompileContext => [allocation = ctx])»
			
		«ENDFOR»
		;-- Constructors ------------------------------------------------
		«FOR constructor : ctx.constructors.values.sortBy[type.name]»
			«constructor.compile(null)»
			
		«ENDFOR»
		«val dmcList = ctx.prgRoms.values.filter[DMC].toList»
		«IF dmcList.isNotEmpty»
			;-- DMC sound data-----------------------------------------------
				.org «Members::FT_DPCM_OFF»
			«FOR dmcRom : dmcList»
				«dmcRom.compile(new CompileContext)»
			«ENDFOR»
		«ENDIF»
		
		;----------------------------------------------------------------
		; Interrupt vectors
		;----------------------------------------------------------------
			.org $FFFA     
		
		 	.dw «ctx.methods.values.findFirst[nmi].nameOf»
		 	.dw «ctx.methods.values.findFirst[reset].nameOf»
		 	.dw «ctx.methods.values.findFirst[irq].nameOf»
		
		;----------------------------------------------------------------
		; CHR-ROM bank(s)
		;----------------------------------------------------------------
		   .base $0000
		
		«FOR rom : ctx.chrRoms.values»
			«rom.compile(new CompileContext)»
		«ENDFOR»
	'''

	private def toHexString(int value) {
		value.toHexString(2)
	}

	private def toHexString(int value, int len) {
		var string = Integer.toHexString(value).toUpperCase

		while (string.length < len) {
			string = '0' + string
		}

		return '$' + string
	}

	private def fieldValue(NewInstance instance, String fieldname) {
		instance?.constructor?.fields?.findFirst [
			variable.name == fieldname
		]?.value?.valueOf ?: instance.type.allFieldsBottomUp.findFirst [
			name == fieldname
		].valueOf

	}

	private def void noop() {
	}
}
