/*
 * generated by Xtext 2.10.0
 */
package org.parisoft.noop.generator

import com.google.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.IResourceDescriptions
import org.parisoft.noop.^extension.Classes
import org.parisoft.noop.^extension.Expressions
import org.parisoft.noop.^extension.Members
import org.parisoft.noop.^extension.TypeSystem
import org.parisoft.noop.noop.NoopClass
import org.parisoft.noop.noop.NoopPackage
import org.parisoft.noop.noop.Variable

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class NoopGenerator extends AbstractGenerator {

	@Inject extension Classes
	@Inject extension Members
	@Inject extension Expressions
	@Inject extension IQualifiedNameProvider
	@Inject IResourceDescriptions descriptions

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val asm = resource.compile

		if (asm !== null) {
			fsa.generateFile(asm.filename, asm.content)
		}
	}

	private def compile(Resource resource) {
		val game = resource.gameClass

		if (game === null) {
			return null
		}

		val content = game.alloc.compile

		new ASM('''«game.name».asm''', content.toString)
	}

	private def gameClass(Resource resource) {
		val games = descriptions.allResourceDescriptions.map [
			getExportedObjectsByType(NoopPackage::eINSTANCE.noopClass)
		].flatten.map [
			var obj = it.EObjectOrProxy

			if (obj.eIsProxy) {
				obj = resource.resourceSet.getEObject(it.EObjectURI, true)
			}

			obj as NoopClass
		].filter [
			it.isGame && it.name != TypeSystem::LIB_GAME
		].toSet

		if (games.size > 1) {
			throw new IllegalArgumentException("More than 1 game implementation found: " + games.map[name])
		}

		return games.head
	}

	private def compile(MetaData data) '''
		;----------------------------------------------------------------
		; Class Metadata
		;----------------------------------------------------------------
		«var classCount = 0»
		«FOR noopClass : data.classes.filter[nonPrimitive]»
			«noopClass.name».class = «classCount++»
			«var fieldOffset = 0»
			«FOR field : noopClass.inheritedFields.filter[nonConstant]»
				«field.fullyQualifiedName.toString» = «fieldOffset += field.sizeOf»
			«ENDFOR»
			
		«ENDFOR»
		;----------------------------------------------------------------
		; Constants
		;----------------------------------------------------------------
		«FOR cons : data.constants.sortBy[fullyQualifiedName]»
			«cons.fullyQualifiedName.toString» = «cons.valueOf.toString»
		«ENDFOR»
		
		;----------------------------------------------------------------
		; Singletons
		;----------------------------------------------------------------
		«val varStartAddr = data.resetVarCounter»
		«FOR singleton : data.singletons»
			_«singleton.name.toLowerCase» = «data.varCounter.getAndAdd(singleton.sizeOf).toHexString(4)»
		«ENDFOR»
		
		;----------------------------------------------------------------
		; Variables
		;----------------------------------------------------------------
		«FOR chunk : data.pointers.values.flatten.sort»
			«chunk.variable» = «chunk.lo.toHexString(4)»
		«ENDFOR»
		
		«val delta = data.varCounter.get - varStartAddr»
		«FOR chunk : data.variables.values.flatten.sort»
			«chunk.shiftTo(delta)»
			«chunk.variable» = «chunk.lo.toHexString(4)»
		«ENDFOR»
		
		;----------------------------------------------------------------
		; iNES Header
		;----------------------------------------------------------------
			.db 'NES', $1A ;identification of the iNES header
			.db «(data.header.fieldValue('prgRomPages') as Integer).toHexString» ;number of 16KB PRG-ROM pages
			.db «(data.header.fieldValue('chrRomPages') as Integer).toHexString» ;number of 8KB CHR-ROM pages
			.db «(data.header.fieldValue('mapper') as Integer).toHexString» | «(data.header.fieldValue('mirroring') as Integer).toHexString»
			.dsb 9, $00 ;clear the remaining bytes
			
		;----------------------------------------------------------------
		; PRG-ROM Bank(s)
		;----------------------------------------------------------------
			.base $10000 - («(data.header.fieldValue('prgRomPages') as Integer).toHexString» * $4000) 
		
		«FOR rom : data.prgRoms»
			«rom.fullyQualifiedName»:
				«rom.value.compile(data)»
		«ENDFOR»
		
		«FOR method : data.methods.sortBy[fullyQualifiedName]»
			«method.compile(data)»
			
		«ENDFOR»
		«FOR constructor : data.constructors.sortBy[type.name]»
			«constructor.compile(data)»
			
		«ENDFOR»
		;----------------------------------------------------------------
		; Interrupt vectors
		;----------------------------------------------------------------
			.org $FFFA     
		
		 	.dw «data.methods.findFirst[nmi].asmName»
		 	.dw «data.methods.findFirst[main].asmName»
		 	.dw 0 ; IRQ
		
		;----------------------------------------------------------------
		; CHR-ROM bank(s)
		;----------------------------------------------------------------
		   .base $0000
		
		«FOR rom : data.chrRoms»
			«rom.fullyQualifiedName»:
				«rom.value.compile(data)»
		«ENDFOR»
	'''

	private def toHexString(int value) {
		value.toHexString(2)
	}

	private def toHexString(int value, int len) {
		var string = Integer.toHexString(value).toUpperCase

		while (string.length < len) {
			string = '0' + string
		}

		return '$' + string
	}

	private def fieldValue(Variable variable, String fieldname) {
		(variable.valueOf as NoopInstance).fields.findFirst[it.name == fieldname]?.valueOf
	}
}
